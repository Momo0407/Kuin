var inputBoxWndMain: wnd@Wnd
var inputBoxLabelText: wnd@Label
var inputBoxBtnOk: wnd@Btn
var inputBoxBtnCancel: wnd@Btn
var inputBoxEditInput: wnd@Edit
var inputBoxValidate: func<([]char):bool>
var inputBoxResult: []char

+func inputBox(parent: wnd@Wnd, text: []char, title: []char, defaultValue: []char, validate: func<([]char):bool>): []char
	do @inputBoxWndMain :: wnd@makeWnd(parent, (%fix $ wnd@WndStyle).or(%noMinimize), 353, 120, title)
	var screenWidth: int
	var screenHeight: int
	do wnd@screenSize(&screenWidth, &screenHeight)
	var wndWidth: int
	var wndHeight: int
	do @inputBoxWndMain.getPosScreen(&, &, &wndWidth, &wndHeight)
	do @inputBoxWndMain.setPos((screenWidth - wndWidth) / 2, (screenHeight - wndHeight) / 2, wndWidth, wndHeight)
	do @inputBoxLabelText :: wnd@makeLabel(@inputBoxWndMain, 12, 12, 270, 72, %fix, %fix, text)
	do @inputBoxBtnOk :: wnd@makeBtn(@inputBoxWndMain, 281, 12, 60, 23, %fix, %fix, "OK")
	do @inputBoxBtnOk.onPush :: btnOkOnPush
	do @inputBoxBtnCancel :: wnd@makeBtn(@inputBoxWndMain, 281, 41, 60, 23, %fix, %fix, "Cancel")
	do @inputBoxBtnCancel.onPush :: btnCancelOnPush
	do @inputBoxEditInput :: wnd@makeEdit(@inputBoxWndMain, 12, 89, 329, 19, %fix, %fix)
	if(defaultValue <>& null)
		do @inputBoxEditInput.setText(defaultValue)
	end if
	do @inputBoxValidate :: validate
	do @inputBoxResult :: null
	do @inputBoxWndMain.modal()
	var result: []char :: @inputBoxResult
	do @inputBoxWndMain :: null
	do @inputBoxLabelText :: null
	do @inputBoxBtnOk :: null
	do @inputBoxBtnCancel :: null
	do @inputBoxEditInput :: null
	do @inputBoxValidate :: null
	do @inputBoxResult :: null
	ret result

	func btnOkOnPush(wnd: wnd@Btn)
		var text: []char :: @inputBoxEditInput.getText()
		if(@inputBoxValidate =& null | @inputBoxValidate(text))
			do @inputBoxResult :: text
			do @inputBoxWndMain.close()
		end if
	end func

	func btnCancelOnPush(wnd: wnd@Btn)
		do @inputBoxWndMain.close()
	end func
end func

+func makeKnwnd(path: []char, parent: wnd@WndBase): wnd@WndBase
	try
		ret buildRecursion(xml@makeXml(path).root().firstChild().next(), parent, 0, 0)
	catch
		ret null
	end try

	func buildRecursion(node: xml@Node, parent: wnd@WndBase, parentX: int, parentY: int): wnd@WndBase
		var result: wnd@WndBase

		var x: int :: parseInt(node, "x") - parentX
		var y: int :: parseInt(node, "y") - parentY
		var width: int :: parseInt(node, "width")
		var height: int :: parseInt(node, "height")

		var isRoot: bool :: false
		switch(node.getName())
		case "root"
			do result :: wnd@makeWnd(parent, %normal, width, height, parseStr(node, "text"))
			do isRoot :: true
		case "button"
			do result :: wnd@makeBtn(parent, x, y, width, height, %fix, %fix, parseStr(node, "text"))
		end switch
		do result.name :: parseStr(node, "name")
		if(!isRoot)
			if(!parseBool(node, "enabled"))
				do result.enable(false)
			end if
			if(!parseBool(node, "visible"))
				do result.setVisible(false)
			end if
		end if

		var child: xml@Node :: node.firstChild()
		while(child <>& null)
			do buildRecursion(child, result, x, y)
			do child :: child.next()
		end while

		ret result

		func parseStr(node: xml@Node, prop: []char): []char
			var result: []char :: node.getAttr(prop)
			ret result =& null ?("", result)
		end func

		func parseInt(node: xml@Node, prop: []char): int
			var attr: []char :: node.getAttr(prop)
			if(attr =& null)
				ret 0
			end if
			var result: int
			if(attr.toInt(&result))
				ret result
			else
				ret 0
			end if
		end func

		func parseBool(node: xml@Node, prop: []char): bool
			var attr: []char :: node.getAttr(prop)
			if(attr =& null)
				ret false
			end if
			ret attr = "true"
		end func
	end func
end func

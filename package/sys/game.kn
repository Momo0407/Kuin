func [d1004.knd, _init] _init()
end func

+class Rect()
	+func [d1004.knd, _rectMove] move(maxVelo: float)
	end func

	+func [d1004.knd, _rectUpdate] update()
	end func

	+func hitLeft(): bool
		ret me.flags.and(0x01b64) <> 0b64
	end func

	+func hitTop(): bool
		ret me.flags.and(0x02b64) <> 0b64
	end func

	+func hitRight(): bool
		ret me.flags.and(0x04b64) <> 0b64
	end func

	+func hitBottom(): bool
		ret me.flags.and(0x08b64) <> 0b64
	end func

	+var x: float
	+var y: float
	+var width: float
	+var height: float
	+var veloX: float
	+var veloY: float
	+var weight: float
	+var flags: bit64
	var buf0: float
	var buf1: float
	var buf2: float
	var buf3: float
	var buf4: float
	var buf5: float
	var buf6: float
	var buf7: float
	var buf8: float
end class

+func [d1004.knd, _makeRect, _make_instance] makeRect(me2: @Rect, x: float, y: float, width: float, height: float, weight: float): @Rect
end func

+class Map()
	*func [d1004.knd, _mapDtor, _force] _dtor()
	end func

	*func [_force] _copy(): kuin@Class
		throw 0xE9170005
	end func

	*func [_force] _toBin(): []bit8
		throw 0xE9170005
	end func

	*func [_force] _fromBin(bin: []bit8, idx: &int): kuin@Class
		throw 0xE9170005
	end func

	+func [d1004.knd, _mapGet] get(x: int, y: int): int
	end func

	+func set(x: int, y: int, value: int)
	end func

	+func find(x: &int, y: &int, value: int): bool
	end func

	var mapWidth: int
	var mapHeight: int
	var buf: int
	var blockWidth: float
	var blockHeight: float
end class

+func makeMap(path: []char, blockWidth: float, blockHeight: float): @Map
	var handle: file@Reader :: file@makeReader(path)
	do handle.delimiter([','])
	var mapWidth: int :: handle.readInt()
	var mapHeight: int :: handle.readInt()
	var buf: []int :: #[mapWidth * mapHeight]int
	for i(0, mapWidth * mapHeight - 1)
		do buf[i] :: handle.readInt()
	end for
	ret makeMapImpl(mapWidth, mapHeight, buf, blockWidth, blockHeight)

	func [d1004.knd, _makeMapImpl, _make_instance] makeMapImpl(me2: @Map, mapWidth: int, mapHeight: int, data: []int, blockWidth: float, blockHeight: float): @Map
	end func
end func

+func [d1004.knd, _makeMapEmpty, _make_instance] makeMapEmpty(me2: @Map, mapWidth: int, mapHeight: int, blockWidth: float, blockHeight: float): @Map
end func

+enum Shape
	none
	rect
	triLeftTop
	triRightTop
	triLeftBottom
	triRightBottom
end enum

+class BlockInfo()
	+var shape: @Shape
	+var backFriction: float
	+var solidFriction: float
	+var fluidFriction: float
	+var repulsion: float
end class

+func hitMapRect(map: @Map, rect: @Rect, callback: func<(int, @BlockInfo)>)
	do hitMapRectImpl(map, rect, callback)

	func [d1004.knd, _hitMapRectImpl, _make_instance] hitMapRectImpl(me2: @BlockInfo, map: @Map, rect: @Rect, callback: func<(int, @BlockInfo)>): @BlockInfo
	end func
end func

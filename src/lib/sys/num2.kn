func main()
	var a: @BigInt :: @makeBigIntFromStr("1000000000000000")
	var b: @BigInt :: @makeBigIntFromStr("1000000000000000")
	var c: @BigInt :: a.mul(b)
	do cui@print(a.toInt().toStr() ~ "\n")
	do cui@print(b.toInt().toStr() ~ "\n")
	do cui@print(c.toInt().toStr() ~ "\n")
end func

+class BigInt()
	*func[__ndc]ctor()
	end func
	
	+*func cmp(t: kuin@Class): int
		var t2: @BigInt :: t $ @BigInt
		if(me.minus <> t2.minus)
			ret me.minus ?(-1, 1)
		elif(^me.value <> ^t2.value)
			if(^me.value > ^t2.value)
				ret me.minus ?(-1, 1)
			else
				ret me.minus ?(1, -1)
			end if
		else
			for i(^me.value - 1, 0, -1)
				if(me.value[i] > t2.value[i])
					ret me.minus ?(-1, 1)
				elif(me.value[i] < t2.value[i])
					ret me.minus ?(1, -1)
				end if
			end for
			ret 0
		end if
	end func
	
	+*func toStr(): []char
		; TODO:
	end func
	
	+func fromInt(value: int)
		if(value >= 0)
			do me.value :: [value $ bit64]
			do me.minus :: false
		else
			do me.value :: [(-value) $ bit64]
			do me.minus :: true
		end if
	end func
	
	+func fromStr(value: []char)
		var tmp: @BigInt :: @makeBigInt()
		var tmp2: @BigInt :: @makeBigIntFromInt(1000000000000000000)
		var success: bool
		var start: int
		var minus: bool
		if(^value >= 1 & value[0] = '-')
			do start :: 1
			do minus :: true
		else
			do start :: 0
			do minus :: false
		end if
		do me.value :: [0b64]
		do me.minus :: false
		while(start < ^value & value[start] = '0')
			do start :+ 1
		end while
		var ptr: int :: ^value - 1
		while(ptr - 17 >= start)
			do tmp.value :: [value.sub(ptr - 17, 18).toBit64(&success)]
			if(!success)
				throw 0xE9170008
			end if
			do tmp.minus :: false
			do @mulImpl(me, tmp2)
			do @addImpl(me, tmp)
			do ptr :- 18
		end while
		if(ptr >= start)
			do tmp.value :: [value.sub(start, ptr - start + 1).toBit64(&success)]
			if(!success)
				throw 0xE9170008
			end if
			do tmp.minus :: false
			do @mulImpl(me, tmp2)
			do @addImpl(me, tmp)
		end if
		do me.minus :: minus
		if(^me.value = 1 & me.value[0] = 0b64)
			do me.minus :: false
		end if
	end func
	
	+func toInt(): int
		if(me.minus)
			ret -(me.value[0] $ int)
		else
			ret me.value[0] $ int
		end if
	end func
	
	+func[__mki]add(me2: @BigInt, value: @BigInt): @BigInt
		do me2.value :: me.value
		do me2.minus :: me.minus
		do @addImpl(me2, value)
		ret me2
	end func
	
	+func[__mki]sub(me2: @BigInt, value: @BigInt): @BigInt
		var tmpMinus: bool :: value.minus
		do me2.value :: me.value
		do me2.minus :: me.minus
		do value.minus :: !value.minus
		do @addImpl(me2, value)
		do value.minus :: tmpMinus
		ret me2
	end func
	
	+func[__mki]mul(me2: @BigInt, value: @BigInt): @BigInt
		do me2.value :: me.value
		do me2.minus :: me.minus
		do @mulImpl(me2, value)
		ret me2
	end func
	
	+func[__mki]div(me2: @BigInt, value: @BigInt): @BigInt
		; TODO:
	end func
	
	+func[__mki]mod(me2: @BigInt, value: @BigInt): @BigInt
		; TODO:
	end func
	
	+func[__mki]powInt(me2: @BigInt, value: int): @BigInt
		; TODO:
	end func
	
	+func[__mki]abs(me2: @BigInt): @BigInt
		; TODO:
	end func
	
	+var value: []bit64
	+var minus: bool
end class

+func[__mki]makeBigInt(me2: @BigInt): @BigInt
	do me2.fromInt(0)
	ret me2
end func

+func[__mki]makeBigIntFromInt(me2: @BigInt, value: int): @BigInt
	do me2.fromInt(value)
	ret me2
end func

+func[__mki]makeBigIntFromStr(me2: @BigInt, value: []char): @BigInt
	do me2.fromStr(value)
	ret me2
end func

func addImpl(a: @BigInt, b: @BigInt)
	if(a.minus)
		if(b.minus)
			do a.value :: @addBit64s(a.value, b.value)
		else
			do a.value :: @trim(@subBit64s(b.value, a.value, &a.minus))
		end if
	else
		if(b.minus)
			do a.value :: @trim(@subBit64s(a.value, b.value, &a.minus))
		else
			do a.value :: @addBit64s(a.value, b.value)
		end if
	end if
end func

func mulImpl(a: @BigInt, b: @BigInt)
	var a2: []bit64 :: a.value
	var b2: []bit64 :: b.value
	var size: int :: 1
	while(size < ^a2 | size < ^b2)
		do size :* 2
	end while
	if(^a2 < size)
		do a2 :: a2 ~ #[size - ^a2]bit64
	elif(^b2 < size)
		do b2 :: b2 ~ #[size - ^b2]bit64
	end if
	do a.value :: @trim(mul64Recursion(a2, b2))
	do a.minus :: a.minus <> b.minus
	if(^a.value = 1 & a.value[0] = 0b64)
		do a.minus :: false
	end if
	
	func mul64Recursion(a: []bit64, b: []bit64): []bit64
		if(^a = 1)
			ret mul64Last(a[0], b[0])
		end if
		var half: int :: ^a / 2
		var x0: []bit64 :: a.sub(0, half)
		var y0: []bit64 :: b.sub(0, half)
		var x1: []bit64 :: a.sub(half, -1)
		var y1: []bit64 :: b.sub(half, -1)
		var z2: []bit64 :: mul64Recursion(x1, y1)
		var z0: []bit64 :: mul64Recursion(x0, y0)
		var minus0: bool
		var x1x0: []bit64 :: @subBit64s(x1, x0, &minus0)
		var minus1: bool
		var y1y0: []bit64 :: @subBit64s(y1, y0, &minus1)
		var z1: []bit64
		if(minus0 = minus1)
			do z1 :: @subBit64s(@addBit64s(z2, z0), mul64Recursion(x1x0, y1y0), &)
		else
			do z1 :: @addBit64s(@addBit64s(z2, z0), mul64Recursion(x1x0, y1y0))
		end if
		ret @addBit64s(@addBit64s(#[^a]bit64 ~ z2, #[half]bit64 ~ z1), z0)
	end func
	
	func mul64Last(a: bit64, b: bit64): []bit64
		var x0: bit64 :: a.and(0xFFFFFFFFb64)
		var y0: bit64 :: b.and(0xFFFFFFFFb64)
		var x1: bit64 :: a.shr(32)
		var y1: bit64 :: b.shr(32)
		var z2Array: []bit64 :: [x1 * y1]
		var z0Array: []bit64 :: [x0 * y0]
		var minus0: bool :: x1 < x0
		var x1x0: bit64 :: minus0 ?(x0 - x1, x1 - x0)
		var minus1: bool :: y1 < y0
		var y1y0: bit64 :: minus1 ?(y0 - y1, y1 - y0)
		var z1: []bit64
		if(minus0 = minus1)
			do z1 :: @subBit64s(@addBit64s(z2Array, z0Array), [x1x0 * y1y0], &)
		else
			do z1 :: @addBit64s(@addBit64s(z2Array, z0Array), [x1x0 * y1y0])
		end if
		if(^z1 = 1)
			do z1 :: [z1[0].and(0xFFFFFFFFb64).shl(32), z1[0].shr(32)]
		else
			do z1 :: [z1[0].and(0xFFFFFFFFb64).shl(32), z1[0].shr(32).or(z1[1].and(0xFFFFFFFFb64).shl(32))]
		end if
		ret @addBit64s(@addBit64s(#[1]bit64 ~ z2Array, z1), z0Array)
	end func
end func

func addBit64s(a: []bit64, b: []bit64): []bit64
	var r: []bit64 :: #[^a >= ^b ?(^a, ^b)]bit64
	var carry: bool :: false
	for i(0, ^r - 1)
		var a2: bit64 :: i >= ^a ?(0b64, a[i])
		var b2: bit64 :: i >= ^b ?(0b64, b[i])
		var r2: bit64 :: 0b64
		var carry2: bool :: false
		if(a2 > lib@bit64Max - b2)
			do carry2 :: true
		end if
		do r2 :: a2 + b2
		if(carry)
			if(r2 > lib@bit64Max - 1b64)
				do carry2 :: true
			end if
			do r2 :+ 1b64
		end if
		do r[i] :: r2
		do carry :: carry2
	end for
	if(carry)
		do r :~ [1b64]
	end if
	ret r
end func

func subBit64s(a: []bit64, b: []bit64, carry: &bool): []bit64
	var r: []bit64 :: #[^a >= ^b ?(^a, ^b)]bit64
	do carry :: false
	for i(0, ^r - 1)
		var a2: bit64 :: i >= ^a ?(0b64, a[i])
		var b2: bit64 :: i >= ^b ?(0b64, b[i])
		var r2: bit64 :: 0b64
		var carry2: bool :: false
		if(a2 < b2)
			do carry2 :: true
		end if
		do r2 :: a2 - b2
		if(carry)
			if(r2 < 1b64)
				do carry2 :: true
			end if
			do r2 :- 1b64
		end if
		do r[i] :: r2
		do carry :: carry2
	end for
	if(carry)
		var added: bool :: false
		for i(0, ^r - 1)
			do r[i] :: r[i].not()
			if(!added)
				if(r[i] <> lib@bit64Max)
					do added :: true
				end if
				do r[i] :+ 1b64
			end if
		end for
	end if
	ret r
end func

func trim(n: []bit64): []bit64
	for i(^n - 1, 0, -1)
		if(n[i] <> 0b64)
			ret i = ^n - 1 ?(n, n.sub(0, i + 1))
		end if
	end for
	ret [0b64]
end func

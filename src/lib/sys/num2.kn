func main()
	var a: @BigInt :: @makeBigIntFromStr("1000000000000000000000000000000000000000000000000000")
	var b: @BigInt :: @makeBigIntFromStr("1000000000000000000000000000000000000000000000000000")
	var c: @BigInt :: a.add(b)
	do cui@print(a.toInt().toStr() ~ "\n")
	do cui@print(b.toInt().toStr() ~ "\n")
	do cui@print(c.toInt().toStr() ~ "\n")
end func

+class BigInt()
	*func[__ndc]ctor()
	end func
	
	+*func cmp(t: kuin@Class): int
		var t2: @BigInt :: t $ @BigInt
		if(me.minus <> t2.minus)
			ret me.minus ?(-1, 1)
		elif(^me.value <> ^t2.value)
			if(^me.value > ^t2.value)
				ret me.minus ?(-1, 1)
			else
				ret me.minus ?(1, -1)
			end if
		else
			for i(^me.value - 1, 0, -1)
				if(me.value[i] > t2.value[i])
					ret me.minus ?(-1, 1)
				elif(me.value[i] < t2.value[i])
					ret me.minus ?(1, -1)
				end if
			end for
			ret 0
		end if
	end func
	
	+*func toStr(): []char
		; TODO:
	end func
	
	+func fromInt(value: int)
		if(value >= 0)
			do me.value :: [value $ bit64]
			do me.minus :: false
		else
			do me.value :: [(-value) $ bit64]
			do me.minus :: true
		end if
	end func
	
	+func fromStr(value: []char)
		var tmp: @BigInt :: @makeBigInt()
		var tmp2: @BigInt :: @makeBigIntFromInt(1000000000000000000)
		var success: bool
		var start: int
		var minus: bool
		if(^value >= 1 & value[0] = '-')
			do start :: 1
			do minus :: true
		else
			do start :: 0
			do minus :: false
		end if
		do me.value :: [0b64]
		do me.minus :: false
		while(start < ^value & value[start] = '0')
			do start :+ 1
		end while
		var ptr: int :: ^value - 1
		while(ptr - 17 >= start)
			do tmp.value :: [value.sub(ptr - 17, 18).toBit64(&success)]
			if(!success)
				throw 0xE9170008
			end if
			do tmp.minus :: false
			do @mulImpl(me, tmp2)
			do @addImpl(me, tmp)
			do ptr :- 18
		end while
		if(ptr >= start)
			do tmp.value :: [value.sub(start, ptr - start + 1).toBit64(&success)]
			if(!success)
				throw 0xE9170008
			end if
			do tmp.minus :: false
			do @mulImpl(me, tmp2)
			do @addImpl(me, tmp)
		end if
		do me.minus :: minus
		if(^me.value = 1 & me.value[0] = 0b64)
			do me.minus :: false
		end if
	end func
	
	+func toInt(): int
		if(me.minus)
			ret -(me.value[0] $ int)
		else
			ret me.value[0] $ int
		end if
	end func
	
	+func[__mki]add(me2: @BigInt, value: @BigInt): @BigInt
		do me2.value :: me.value
		do me2.minus :: me.minus
		do @addImpl(me2, value)
		ret me2
	end func
	
	+func[__mki]sub(me2: @BigInt, value: @BigInt): @BigInt
		var tmpMinus: bool :: value.minus
		do me2.value :: me.value
		do me2.minus :: me.minus
		do value.minus :: !value.minus
		do @addImpl(me2, value)
		do value.minus :: tmpMinus
		ret me2
	end func
	
	+func[__mki]mul(me2: @BigInt, value: @BigInt): @BigInt
		; TODO:
	end func
	
	+func[__mki]div(me2: @BigInt, value: @BigInt): @BigInt
		; TODO:
	end func
	
	+func[__mki]mod(me2: @BigInt, value: @BigInt): @BigInt
		; TODO:
	end func
	
	+func[__mki]powInt(me2: @BigInt, value: int): @BigInt
		; TODO:
	end func
	
	+func[__mki]abs(me2: @BigInt): @BigInt
		; TODO:
	end func
	
	+var value: []bit64
	+var minus: bool
end class

+func[__mki]makeBigInt(me2: @BigInt): @BigInt
	do me2.fromInt(0)
	ret me2
end func

+func[__mki]makeBigIntFromInt(me2: @BigInt, value: int): @BigInt
	do me2.fromInt(value)
	ret me2
end func

+func[__mki]makeBigIntFromStr(me2: @BigInt, value: []char): @BigInt
	do me2.fromStr(value)
	ret me2
end func

func addImpl(a: @BigInt, b: @BigInt)
	if(a.minus)
		if(b.minus)
			do a.value :: @addBit64s(a.value, b.value)
		else
			do a.value :: @subBit64s(b.value, a.value, &a.minus)
		end if
	else
		if(b.minus)
			do a.value :: @subBit64s(a.value, b.value, &a.minus)
		else
			do a.value :: @addBit64s(a.value, b.value)
		end if
	end if
end func

func mulImpl(a: @BigInt, b: @BigInt)
	; TODO:
end func

func addBit64s(a: []bit64, b: []bit64): []bit64
	var r: []bit64 :: #[^a >= ^b ?(^a, ^b)]bit64
	var carry: bool :: false
	for i(0, ^r - 1)
		var a2: bit64 :: i >= ^a ?(0b64, a[i])
		var b2: bit64 :: i >= ^b ?(0b64, b[i])
		var r2: bit64 :: 0b64
		var carry2: bool :: false
		if(a2 > lib@bit64Max - b2)
			do carry2 :: true
		end if
		do r2 :: a2 + b2
		if(carry)
			if(r2 > lib@bit64Max - 1b64)
				do carry2 :: true
			end if
			do r2 :+ 1b64
		end if
		do r[i] :: r2
		do carry :: carry2
	end for
	if(carry)
		do r :~ [1b64]
	end if
	ret r
end func

func subBit64s(a: []bit64, b: []bit64, carry: &bool): []bit64
	var r: []bit64 :: #[^a >= ^b ?(^a, ^b)]bit64
	do carry :: false
	for i(0, ^r - 1)
		var a2: bit64 :: i >= ^a ?(0b64, a[i])
		var b2: bit64 :: i >= ^b ?(0b64, b[i])
		var r2: bit64 :: 0b64
		var carry2: bool :: false
		if(a2 < b2)
			do carry2 :: true
		end if
		do r2 :: a2 - b2
		if(carry)
			if(r2 < 1b64)
				do carry2 :: true
			end if
			do r2 :- 1b64
		end if
		do r[i] :: r2
		do carry :: carry2
	end for
	if(carry)
		var added: bool :: false
		for i(0, ^r - 1)
			do r[i] :: r[i].not()
			if(!added)
				if(r[i] <> lib@bit64Max)
					do added :: true
				end if
				do r[i] :+ 1b64
			end if
		end for
	end if
	for i(^r - 1, 0, -1)
		if(r[i] <> 0b64)
			ret i = ^r - 1 ?(r, r.sub(0, i + 1))
		end if
	end for
	ret [0b64]
end func

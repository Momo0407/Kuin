+class DocArBase(\doc@Doc)
	**func ctor()
		do me.pageX :: 0
		do me.pageY :: 0
		do me.mode :: %none
		do me.hold :: null
		do me.ctrl :: 0
	end func

	+*func load(path: []char): bool
		try
			var xml: xml@Xml :: xml@makeXml(path)
			var node: xml@Node :: xml.root().lastChild()
			do loadRecursion(me, node, me.obj2dRoot)
		catch
			ret false
		end try
		ret true

		func loadRecursion(doc: @DocArBase, xmlNode: xml@Node, obj2dNode: @Obj2d)
			do obj2dNode.load(xmlNode)
			var node: xml@Node :: xmlNode.firstChild()
			while(node <>& null)
				var newObj2dNode: @Obj2d :: doc.makeObj2d(node.getName())
				do loadRecursion(doc, node, newObj2dNode)
				do obj2dNode.children.add(newObj2dNode)
				do node :: node.next()
			end while
		end func
	end func

	+*func save(path: []char): bool
		try
			var xml: xml@Xml :: xml@makeXmlEmpty()
			var root: xml@Node :: xml.root()
			do saveRecursion(root, me.obj2dRoot)
			do xml.save(path, false)
		catch
			ret false
		end try
		ret true

		func saveRecursion(xmlParentNode: xml@Node, obj2dNode: @Obj2d)
			var node: xml@Node :: xmlParentNode.addChild(obj2dNode.getName())
			do obj2dNode.save(node)
			do obj2dNode.children.head()
			while(!obj2dNode.children.term())
				do saveRecursion(node, obj2dNode.children.get())
				do obj2dNode.children.next()
			end while
		end func
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, \common@colorBack)
		do drawRecursion(me.obj2dRoot, me.pageX, me.pageY, me.hold)

		func drawRecursion(obj: @Obj2d, pageX: int, pageY: int, hold: @Obj2d)
			do draw@rect((obj.x - 2 - pageX) $ float, (obj.y - 2 - pageY) $ float, (obj.width + 4) $ float, (obj.height + 4) $ float, hold =& obj ?(16#FF6666FF, 16#FF666666))
			do obj.draw(pageX, pageY)
			do obj.children.head()
			while(!obj.children.term())
				do drawRecursion(obj.children.get(), pageX, pageY, hold)
				do obj.children.next()
			end while
		end func
	end func

	+*func updateTree(tree: wnd@Tree)
		do updateTreeRecursion(me.hold, tree, tree.root(), me.obj2dRoot)
		do me.addCtrlList(\form@listInfo)
		do \form@listInfo.setSel(me.ctrl)

		func updateTreeRecursion(hold: @Obj2d, tree: wnd@Tree, node: wnd@TreeNode, obj: @Obj2d)
			var node2: wnd@TreeNode :: node.addChild(obj.objName)
			if(hold =& obj)
				do tree.setSel(node2)
			end if
			do obj.children.head()
			while(!obj.children.term())
				do updateTreeRecursion(hold, tree, node2, obj.children.get())
				do obj.children.next()
			end while
		end func
	end func

	+*func treeItemOnSel()
		var sel: wnd@TreeNode :: \form@treeItem.getSel()
		do me.hold :: selRecursion(\form@treeItem.root().firstChild(), me.obj2dRoot, sel)
		do \form@paintDrawEditor()

		func selRecursion(node: wnd@TreeNode, obj: @Obj2d, sel: wnd@TreeNode): @Obj2d
			if(node = sel)
				ret obj
			end if
			do obj.children.head()
			var node2: wnd@TreeNode :: node.firstChild()
			while(!obj.children.term() & node2 <>& null)
				var result: @Obj2d :: selRecursion(node2, obj.children.get(), sel)
				if(result <>& null)
					ret result
				end if
				do node2 :: node2.next()
				do obj.children.next()
			end while
			ret null
		end func
	end func

	+*func treeItemOnMoveNode()
		do me.obj2dRoot :: updateObjRecursion(\form@treeItem.root().firstChild(), me.obj2dRoot) $ @Obj2dRoot
		do \form@updateTree()
		do \form@paintDrawEditor()

		func updateObjRecursion(node: wnd@TreeNode, objRoot: @Obj2d): @Obj2d
			var obj: @Obj2d :: searchRecursion(node.getName(), objRoot)
			var newObj: @Obj2d :: ##obj
			do newObj.children :: #list<@Obj2d>
			var node2: wnd@TreeNode :: node.firstChild()
			while(node2 <>& null)
				do newObj.children.add(updateObjRecursion(node2, objRoot))
				do node2 :: node2.next()
			end while
			ret newObj

			func searchRecursion(name: []char, obj: @Obj2d): @Obj2d
				if(name = obj.objName)
					ret obj
				end if
				do obj.children.head()
				while(!obj.children.term())
					var result: @Obj2d :: searchRecursion(name, obj.children.get())
					if(result <>& null)
						ret result
					end if
					do obj.children.next()
				end while
				ret null
			end func
		end func
	end func

	+*func listInfoOnSel()
		var sel: int :: \form@listInfo.getSel()
		do me.ctrl :: sel < 0 ?(0, sel)
	end func

	+*func mouseDownL(x: int, y: int)
		var x2: int :: x + me.pageX
		var y2: int :: y + me.pageY
		if(me.ctrl <= 0)
			do me.hold :: selRecursion(me.obj2dRoot, x2, y2)
			if(me.hold =& null)
				do me.hold :: me.obj2dRoot
			end if
			if(me.hold =& me.obj2dRoot)
				do me.mode :: %none
			else
				if(me.hold.x + me.hold.width - resizeArea <= x2 & me.hold.y + me.hold.height - resizeArea <= y2)
					do me.mode :: %resize
					do me.holdOffsetX :: me.hold.x + me.hold.width - x2
					do me.holdOffsetY :: me.hold.y + me.hold.height - y2
				else
					do me.mode :: %move
					do me.holdOffsetX :: me.hold.x - x2
					do me.holdOffsetY :: me.hold.y - y2
				end if
			end if
		else
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			var name: []char :: \form@listInfo.getText(me.ctrl)
			do me.mode :: %put
			do me.holdOffsetX :: 0
			do me.holdOffsetY :: 0
			var obj: @Obj2d :: me.makeObj2d(name)
			var minWidth: int
			var minHeight: int
			do obj.getMinMaxSize(&minWidth, &minHeight, &, &)
			do obj.init(me.getDefaultName(name), x2, y2, minWidth, minHeight)
			if(me.hold =& null)
				do me.obj2dRoot.children.add(obj)
			else
				do me.hold.children.add(obj)
			end if
			do me.hold :: obj
			do me.changed :: true
		end if
		do \form@updateTree()
		do \form@paintDrawEditor()

		func selRecursion(obj: @Obj2d, x: int, y: int): @Obj2d
			var result: @Obj2d :: null
			if(obj.x <= x & x <= obj.x + obj.width & obj.y <= y & y <= obj.y + obj.height)
				do result :: obj
			end if
			do obj.children.head()
			while(!obj.children.term())
				var result2: @Obj2d :: selRecursion(obj.children.get(), x, y)
				if(result2 <>& null)
					do result :: result2
				end if
				do obj.children.next()
			end while
			ret result
		end func
	end func

	+*func mouseUpL(x: int, y: int)
		switch(me.mode)
		case %put
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.resizeObj2d(x + me.pageX, y + me.pageY)
			do me.mode :: %none
			do me.ctrl :: 0
			do \form@updateTree()
			do \form@paintDrawEditor()
		case %move
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.moveObj2d(x + me.pageX, y + me.pageY)
			do me.mode :: %none
			do \form@updateTree()
			do \form@paintDrawEditor()
		case %resize
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.resizeObj2d(x + me.pageX, y + me.pageY)
			do me.mode :: %none
			do \form@updateTree()
			do \form@paintDrawEditor()
		end switch
	end func

	+*func mouseDoubleClick(x: int, y: int)
		; TODO:
	end func

	+*func mouseMove(x: int, y: int)
		switch(me.mode)
		case %put
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.resizeObj2d(x + me.pageX, y + me.pageY)
			do \form@paintDrawEditor()
		case %move
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.moveObj2d(x + me.pageX, y + me.pageY)
			do \form@paintDrawEditor()
		case %resize
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.resizeObj2d(x + me.pageX, y + me.pageY)
			do \form@paintDrawEditor()
		end switch
	end func

	+*func focus(isFocus: bool)
		if(isFocus)
			do me.refreshScroll()
		end if
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl): bool
		; TODO:
	end func

	+*func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		; TODO:
	end func

	+*func keyChar(key: char)
		; TODO:
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos
		do \form@paintDrawEditor()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos
		do \form@paintDrawEditor()
	end func

	+*func wheelX(wheel: int)
		; TODO:
	end func

	+*func wheelY(wheel: int)
		; TODO:
	end func

	+*func setMouseImg(): wnd@MouseImg
		switch(me.mode)
		case %none
			if(me.hold <>& null)
				var x: int
				var y: int
				do input@mousePos(&x, &y)
				do \form@drawEditor.screenToClient(&x, &y, x, y)
				do x :+ me.pageX
				do y :+ me.pageY
				if(me.hold.x <= x & me.hold.y <= y & x <= me.hold.x + me.hold.width & y <= me.hold.y + me.hold.height)
					if(me.hold.x + me.hold.width - resizeArea <= x & me.hold.y + me.hold.height - resizeArea <= y)
						ret %resizeLTRD
					end if
					ret %move
				end if
			end if
			ret %arrow
		case %put
			ret %cross
		case %move
			ret %move
		case %resize
			ret %resizeLTRD
		default
			assert false
		end switch
	end func

	+*func cmdUndo()
		; TODO:
	end func

	+*func cmdRedo()
		; TODO:
	end func

	+*func cmdCut()
		; TODO:
	end func

	+*func cmdCopy()
		; TODO:
	end func

	+*func cmdPaste()
		; TODO:
	end func

	+*func cmdDel()
		if(me.hold =& null | me.hold =& me.obj2dRoot)
			ret
		end if
		do delRecursion(\form@treeItem.root().firstChild(), me.obj2dRoot, me.hold)
		do \form@updateTree()
		do \form@paintDrawEditor()

		func delRecursion(node: wnd@TreeNode, obj: @Obj2d, hold: @Obj2d): bool
			var node2: wnd@TreeNode :: node.firstChild()
			do obj.children.head()
			while(!obj.children.term() & node2 <>& null)
				var childObj: @Obj2d :: obj.children.get()
				if(hold =& childObj)
					do node.delChild(node2)
					do obj.children.del()
					ret true
				end if
				if(delRecursion(node2, childObj, hold))
					ret true
				end if
				do node2 :: node2.next()
				do obj.children.next()
			end while
			ret false
		end func
	end func

	+*func cmdSelAll()
		; TODO:
	end func

	+*func undoImpl(undo2: \doc@UndoCmd)
		; TODO:
	end func

	const padding: int :: 32
	const resizeArea: int :: 6

	enum Mode
		none
		put
		move
		resize
	end enum

	var src: [][]char
	var obj2dRoot: @Obj2dRoot
	var pageX: int
	var pageY: int
	var mode: Mode
	var hold: @Obj2d
	var ctrl: int
	var holdOffsetX: int
	var holdOffsetY: int

	+func makeObj2d(name: []char): @Obj2d
	end func

	func addCtrlList(ctrlList: wnd@List)
		do ctrlList.add(\common@langEn ?("none", "なし"))
	end func

	func refreshScroll()
		var scrWidth: int
		var scrHeight: int
		do \form@drawEditor.getPos(&, &, &scrWidth, &scrHeight)
		do \form@scrollXSrc.setState(me.obj2dRoot.x, me.obj2dRoot.width + padding, scrWidth, me.pageX)
		do \form@scrollYSrc.setState(me.obj2dRoot.y, me.obj2dRoot.height + padding, scrHeight, me.pageY)
	end func

	func getDefaultName(name: []char): []char
		var num: int :: 1
		var newName: []char
		while loop(true)
			do newName :: name ~ num.toStr()
			if(!searchRecursion(newName, me.obj2dRoot))
				break loop
			end if
			do num :+ 1
		end while
		ret newName

		func searchRecursion(name: []char, obj: @Obj2d): bool
			if(name = obj.objName)
				ret true
			end if
			do obj.children.head()
			while(!obj.children.term())
				if(searchRecursion(name, obj.children.get()))
					ret true
				end if
				do obj.children.next()
			end while
			ret false
		end func
	end func

	func resizeObj2d(x: int, y: int)
		var width: int :: x - me.hold.x + me.holdOffsetX
		var height: int :: y - me.hold.y + me.holdOffsetY
		var minWidth: int
		var minHeight: int
		var maxWidth: int
		var maxHeight: int
		do me.hold.getMinMaxSize(&minWidth, &minHeight, &maxWidth, &maxHeight)
		if(width < minWidth)
			do width :: minWidth
		end if
		if(width > maxWidth)
			do width :: maxWidth
		end if
		if(height < minHeight)
			do height :: minHeight
		end if
		if(height > maxHeight)
			do height :: maxHeight
		end if
		do me.hold.width :: width
		do me.hold.height :: height
	end func

	func moveObj2d(x: int, y: int)
		do me.hold.x :: x + me.holdOffsetX
		do me.hold.y :: y + me.holdOffsetY
	end func
end class

+class Obj2d()
	**func ctor()
		do me.init("root", 0, 0, 1600, 900)
	end func

	+func init(objName: []char, x: int, y: int, width: int, height: int)
		do me.children :: #list<Obj2d>
		do me.objName :: objName
		do me.x :: x
		do me.y :: y
		do me.width :: width
		do me.height :: height
	end func

	+func getName(): []char
	end func

	+func getMinMaxSize(minWidth: &int, minHeight: &int, maxWidth: &int, maxHeight: &int)
		do minWidth :: 10
		do minHeight :: 10
		do maxWidth :: lib@intMax
		do maxHeight :: lib@intMax
	end func

	+func load(node: xml@Node)
		do me.children :: #list<Obj2d>
		do me.objName :: node.getAttr("name")
		do node.getAttr("x").toInt(&me.x)
		do node.getAttr("y").toInt(&me.y)
		do node.getAttr("width").toInt(&me.width)
		do node.getAttr("height").toInt(&me.height)
	end func

	+func save(node: xml@Node)
		do node.setAttr("name", me.objName)
		do node.setAttr("x", me.x.toStr())
		do node.setAttr("y", me.y.toStr())
		do node.setAttr("width", me.width.toStr())
		do node.setAttr("height", me.height.toStr())
	end func

	+func draw(pageX: int, pageY: int)
	end func

	+var children: list<Obj2d>
	+var objName: []char
	+var x: int
	+var y: int
	+var width: int
	+var height: int
end class

+class Obj2dRoot(@Obj2d)
	**func ctor()
		do me.color :: draw@white
	end func

	+*func getName(): []char
		ret "root"
	end func

	+**func load(node: xml@Node)
		do node.getAttr("color").toInt(&me.color)
	end func

	+**func save(node: xml@Node)
		do node.setAttr("color", me.color.toStr())
	end func

	+*func draw(pageX: int, pageY: int)
		do draw@rect((me.x - pageX) $ float, (me.y - pageY) $ float, me.width $ float, me.height $ float, me.color)
	end func

	+var color: int
end class

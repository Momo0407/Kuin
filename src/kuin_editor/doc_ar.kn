+class DocAr(\doc_gen@DocDesigner)
	*func ctor()
		do super(me)
		do me.undo :: #undo@Undo
		do me.undo.init(1024)

		do me.nodes :: #list<@Obj>
		do me.holds :: #list<@Obj>
		do me.scrollOffsetX :: 10
		do me.scrollOffsetY :: 40
		do me.pageX :: -me.scrollOffsetX
		do me.pageY :: -me.scrollOffsetY
		do me.mode :: %none
		do me.updatingProp :: false
	end func

	+*func getSrc(): [][]char
		ret me.src
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, \common@colorBack)
		var offsetX: int :: 0
		var offsetY: int :: 0
		var offsetWidth: int :: 0
		var offsetHeight: int :: 0
		if(me.mode = %put | me.mode = %resize)
			do offsetWidth :: me.curOffsetX - me.holdOffsetX
			do offsetHeight :: me.curOffsetY - me.holdOffsetY
		elif(me.mode = %move)
			do offsetX :: me.curOffsetX - me.holdOffsetX
			do offsetY :: me.curOffsetY - me.holdOffsetY
		end if
		block
			if(^me.holds = 0)
				var x: float :: (me.root.x - me.pageX + offsetX) $ float
				var y: float :: (me.root.y - me.pageY + offsetY) $ float
				var width2: float :: (me.root.width + offsetWidth) $ float
				var height2: float :: (me.root.height + offsetHeight) $ float
				if(me.root.visible)
					do me.root.draw(x, y, width2, height2)
				end if
				do draw@rectLine(x - 3.0, y - 3.0, width2 + 6.0, height2 + 6.0, 0xFF6666FF)
				do draw@rectLine(x - 4.0, y - 4.0, width2 + 8.0, height2 + 8.0, 0xFF6666FF)
			else
				var x: float :: (me.root.x - me.pageX) $ float
				var y: float :: (me.root.y - me.pageY) $ float
				var width2: float :: me.root.width $ float
				var height2: float :: me.root.height $ float
				if(me.root.visible)
					do me.root.draw(x, y, width2, height2)
				end if
			end if
		end block
		do me.nodes.head()
		while(!me.nodes.term())
			var node: @Obj :: me.nodes.get()
			do me.holds.head()
			if(me.holds.find(node))
				var x: float :: (node.x - me.pageX + offsetX) $ float
				var y: float :: (node.y - me.pageY + offsetY) $ float
				var width2: float :: (node.width + offsetWidth) $ float
				var height2: float :: (node.height + offsetHeight) $ float
				if(node.visible)
					do node.draw(x, y, width2, height2)
				end if
				do draw@rectLine(x - 3.0, y - 3.0, width2 + 6.0, height2 + 6.0, 0xFF6666FF)
				do draw@rectLine(x - 4.0, y - 4.0, width2 + 8.0, height2 + 8.0, 0xFF6666FF)
			else
				var x: float :: (node.x - me.pageX) $ float
				var y: float :: (node.y - me.pageY) $ float
				var width2: float :: node.width $ float
				var height2: float :: node.height $ float
				if(node.visible)
					do node.draw(x, y, width2, height2)
				end if
			end if
			do me.nodes.next()
		end while

		if(me.mode = %sel)
			do draw@rectLine((me.holdOffsetX - me.pageX) $ float, (me.holdOffsetY - me.pageY) $ float, (me.curOffsetX - me.holdOffsetX) $ float, (me.curOffsetY - me.holdOffsetY) $ float, 0xFF6666FF)
		end if
	end func

	+*func mouseDownL(x: int, y: int)
		var x2: int :: x + me.pageX
		var y2: int :: y + me.pageY
		do me.holdOffsetX :: x2
		do me.holdOffsetY :: y2
		do me.curOffsetX :: x2
		do me.curOffsetY :: y2

		var idx: int :: \form@listLt.getSel()
		if(idx <= 0)
			var sel: @Obj :: null
			do me.nodes.tail()
			while loop(!me.nodes.term())
				var obj: @Obj :: me.nodes.get()
				if(obj.x <= x2 & x2 <= obj.x + obj.width & obj.y <= y2 & y2 <= obj.y + obj.height)
					do sel :: obj
					break loop
				end if
				do me.nodes.prev()
			end while
			if(sel =& null & me.root.x <= x2 & x2 <= me.root.x + me.root.width & me.root.y <= y2 & y2 <= me.root.y + me.root.height)
				do sel :: me.root
			end if

			if(sel <>& null & sel.x + sel.width - resizeArea <= x2 & sel.y + sel.height - resizeArea <= y2)
				if (\form@getLockingEditor())
					do \form@showMsgRunning()
					ret
				end if
				do me.mode :: %resize
			elif(sel =& null | sel =& me.root)
				do me.mode :: %sel
			else
				if (\form@getLockingEditor())
					do \form@showMsgRunning()
					ret
				end if
				do me.mode :: %move
			end if

			if(sel =& me.root)
				do sel :: null
			end if
			if(sel =& null)
				if(!wnd@key(%shift) & !wnd@key(%ctrl))
					do me.holds :: #list<@Obj>
				end if
			else
				do me.holds.head()
				if (!me.holds.find(sel))
					if(wnd@key(%shift) | wnd@key(%ctrl))
						do me.holds.add(sel)
					else
						do me.holds :: #list<@Obj>
						do me.holds.add(sel)
					end if
				end if
			end if
			do \form@updateUi()
		else
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			var name: []char :: \form@listLt.getText(&, idx, 0)
			var parent: []char :: null
			if(^me.holds > 0)
				do me.holds.tail()
				do me.nodes.head()
				if(me.nodes.find(me.holds.get()))
					do me.nodes.next()
					if(!me.nodes.term())
						do parent :: me.nodes.get().name
					end if
				end if
			end if
			do me.undo.recordBegin()
			do me.put(parent, name, getDefaultName(name.lower(), me.nodes), x2, y2, true)
			do me.undo.recordEnd()
			do me.mode :: %put
		end if
		do \form@paintDrawEditor()

		func getDefaultName(name: []char, nodes: list<@Obj>): []char
			var n: int :: 1
			while loop(true)
				var newName: []char :: name ~ n.toStr()
				var found: bool :: false
				do nodes.head()
				while loop2(!nodes.term())
					if(nodes.get().name = newName)
						do found :: true
						break loop2
					end if
					do nodes.next()
				end while
				if(!found)
					ret newName
				end if
				do n :+ 1
			end while
		end func
	end func

	+*func mouseUpL(x: int, y: int)
		switch(me.mode)
		case %put
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.undo.recordBegin()
			do me.holds.head()
			while(!me.holds.term())
				do me.resizeObj(me.holds.get(), x, y)
				do me.holds.next()
			end while
			do me.undo.recordEnd()
			do me.mode :: %none
			do \form@listLt.setSel(0)
			do me.updateProp()
			do \form@paintDrawEditor()
		case %move
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.undo.recordBegin()
			do me.holds.head()
			while(!me.holds.term())
				var obj: @Obj :: me.holds.get()
				var x2: int :: obj.x + x + me.pageX - me.holdOffsetX
				var y2: int :: obj.y + y + me.pageY - me.holdOffsetY
				if(x2 < 0)
					do x2 :: 0
				end if
				if(y2 < 0)
					do y2 :: 0
				end if
				do me.move(obj.name, x2, y2, obj.width, obj.height, true)
				do me.holds.next()
			end while
			do me.undo.recordEnd()
			do me.mode :: %none
			do me.updateProp()
			do \form@paintDrawEditor()
		case %resize
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.undo.recordBegin()
			if(^me.holds = 0)
				do me.resizeObj(me.root, x, y)
			else
				do me.holds.head()
				while(!me.holds.term())
					do me.resizeObj(me.holds.get(), x, y)
					do me.holds.next()
				end while
			end if
			do me.undo.recordEnd()
			do me.mode :: %none
			do me.updateProp()
			do \form@paintDrawEditor()
		case %sel
			var x1: int :: me.holdOffsetX
			var y1: int :: me.holdOffsetY
			var x2: int :: x + me.pageX
			var y2: int :: y + me.pageY
			if(x1 > x2)
				do x1 :$ x2
			end if
			if(y1 > y2)
				do y1 :$ y2
			end if
			if(!wnd@key(%shift) & !wnd@key(%ctrl))
				do me.holds :: #list<@Obj>
			end if
			do me.nodes.head()
			while(!me.nodes.term())
				var node: @Obj :: me.nodes.get()
				if(node.x <= x2 & x1 <= node.x + node.width & node.y <= y2 & y1 <= node.y + node.height)
					do me.holds.add(node)
				end if
				do me.nodes.next()
			end while
			do me.mode :: %none
			do \form@updateUi()
			do \form@paintDrawEditor()
		end switch
	end func

	+*func mouseDoubleClick(x: int, y: int)
	end func

	+*func mouseMove(x: int, y: int)
		switch(me.mode)
		case %put, %move, %resize
			if (\form@getLockingEditor())
				do \form@showMsgRunning()
				ret
			end if
			do me.curOffsetX :: x + me.pageX
			do me.curOffsetY :: y + me.pageY
			do me.updateProp()
			do \form@paintDrawEditor()
		case %sel
			do me.curOffsetX :: x + me.pageX
			do me.curOffsetY :: y + me.pageY
			do \form@paintDrawEditor()
		end switch
	end func

	+*func focus(isFocus: bool)
		const padding: int :: 32
		if(isFocus)
			var screenWidth: int
			var screenHeight: int
			do \form@drawEditor.getPos(&, &, &screenWidth, &screenHeight)
			do \form@scrollXSrc.setState(me.root.x, me.root.width + padding, screenWidth, me.pageX + me.scrollOffsetX)
			do \form@scrollYSrc.setState(me.root.y, me.root.height + padding, screenHeight, me.pageY + me.scrollOffsetY)
		end if
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl): bool
	end func

	+*func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	end func

	+*func keyChar(key: char)
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos - me.scrollOffsetX
		do \form@paintDrawEditor()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos - me.scrollOffsetY
		do \form@paintDrawEditor()
	end func

	+*func wheelX(wheel: int)
	end func

	+*func wheelY(wheel: int)
	end func

	+*func setMouseImg(): wnd@MouseImg
		switch(me.mode)
		case %none
			var x: int
			var y: int
			do input@mousePos(&x, &y)
			do \form@drawEditor.screenToClient(&x, &y, x, y)
			do x :+ me.pageX
			do y :+ me.pageY
			do me.nodes.tail()
			while(!me.nodes.term())
				var obj: @Obj :: me.nodes.get()
				if(obj.x <= x & x <= obj.x + obj.width & obj.y <= y & y <= obj.y + obj.height)
					if(obj.x + obj.width - resizeArea <= x & obj.y + obj.height - resizeArea <= y)
						ret %resizeLTRD
					end if
					ret %move
				end if
				do me.nodes.prev()
			end while
			if(me.root.x <= x & x <= me.root.x + me.root.width & me.root.y <= y & y <= me.root.y + me.root.height)
				if(me.root.x + me.root.width - resizeArea <= x & me.root.y + me.root.height - resizeArea <= y)
					ret %resizeLTRD
				end if
			end if
			ret %arrow
		case %put
			ret %cross
		case %move
			ret %move
		case %resize
			ret %resizeLTRD
		case %sel
			ret %cross
		default
			assert false
		end switch
	end func

	+*func cmdUndo()
		if(\form@getLockingEditor())
			do \form@showMsgRunning()
			ret
		end if
		do me.undo.undo()
		do \form@paintDrawEditor()
	end func

	+*func cmdRedo()
		if(\form@getLockingEditor())
			do \form@showMsgRunning()
			ret
		end if
		do me.undo.redo()
		do \form@paintDrawEditor()
	end func

	+*func cmdCut()
	end func

	+*func cmdCopy()
	end func

	+*func cmdPaste()
	end func

	+*func cmdDel()
	end func

	+*func cmdSelAll()
	end func

	+*func undoImpl(undo2: \doc@UndoCmd)
		if(undo2 =$ UndoArPut)
			var undo3: UndoArPut :: undo2 $ UndoArPut
			do me.put(undo3.parent, undo3.kind, undo3.name, undo3.x, undo3.y, false)
		elif(undo2 =$ UndoArDel)
			var undo3: UndoArDel :: undo2 $ UndoArDel
			do me.del(undo3.name, false)
		elif(undo2 =$ UndoArMove)
			var undo3: UndoArMove :: undo2 $ UndoArMove
			do me.move(undo3.name, undo3.x, undo3.y, undo3.width, undo3.height, false)
		elif(undo2 =$ UndoArOrder)
			var undo3: UndoArOrder :: undo2 $ UndoArOrder
			do me.order(undo3.names, false)
		elif(undo2 =$ UndoArRename)
			var undo3: UndoArRename :: undo2 $ UndoArRename
			do me.rename(undo3.name, undo3.newName, false)
		elif(undo2 =$ UndoArVisible)
			var undo3: UndoArVisible :: undo2 $ UndoArVisible
			do me.visible(undo3.name, undo3.value, false)
		elif(undo2 =$ UndoArProp)
			var undo3: UndoArProp :: undo2 $ UndoArProp
			do me.prop(undo3.name, undo3.prop, undo3.value, false)
		else
			assert false
		end if
	end func

	+*func getSelCode(): []char
		ret null
	end func

	+*func updateUi()
		do \form@listLt.setRedraw(false)
		do \form@listLt.clear()
		do \form@listLt.style(%large)
		do \form@listLt.add(\common@langEn ?("None", "なし"), -1)
		do me.updateLt()
		do \form@listLt.setRedraw(true)

		do \form@listLb.setRedraw(false)
		do \form@listLb.clear()
		do \form@listLb.style(%list_)
		do me.nodes.head()
		while(!me.nodes.term())
			var obj: @Obj :: me.nodes.get()
			do \form@listLb.add(obj.name, -1)
			do me.holds.head()
			if(me.holds.find(obj))
				do \form@listLb.setSelMulti(\form@listLb.len() - 1, true)
			end if
			do me.nodes.next()
		end while
		do \form@listLb.setRedraw(true)

		do me.updateProp()
	end func

	+*func onEvent(event: \doc@Event)
		if(me.updatingProp)
			ret
		end if
		switch(event)
		case %listLtOnMouseClick
		case %listLbOnMouseClick
			do me.holds :: #list<@Obj>
			var len: int :: \form@listLb.len()
			for i(0, len - 1)
				if(\form@listLb.getSelMulti(i))
					var name: []char :: \form@listLb.getText(&, i, 0)
					do me.find(me.nodes, name)
					do me.holds.add(me.nodes.get())
				end if
			end for
			do me.updateProp()
			do \form@paintDrawEditor()
		case %listLbOnMoveNode
			var len: int :: \form@listLb.len()
			var names: [][]char :: #[len][]char
			for i(0, len - 1)
				do names[i] :: \form@listLb.getText(&, i, 0)
			end for
			do me.undo.recordBegin()
			do me.order(names, true)
			do me.undo.recordEnd()
			do me.updateProp()
			do \form@paintDrawEditor()
		case %listRbOnMouseClick
		case %editRbArNameOnKillFocus
			if(^me.holds <> 1)
				ret
			end if
			do me.holds.head()
			var obj: @Obj :: me.holds.get()
			var name: []char :: \form@editRbArName.getText().trim()
			do me.find(me.nodes, name)
			if(me.nodes.term() & me.root.name <> name)
				do me.undo.recordBegin()
				do me.rename(obj.name, name, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		case %chkRbArVisibleOnPush
			var obj: @Obj
			if(^me.holds = 0)
				do obj :: me.root
			elif(^me.holds = 1)
				do me.holds.head()
				do obj :: me.holds.get()
			else
				ret
			end if
			var chk: bool :: \form@chkRbArVisible.getChk()
			if(obj.visible <> chk)
				do me.undo.recordBegin()
				do me.visible(obj =& me.root ?(null, obj.name), chk, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		case %editRbArXOnKillFocus
			if(^me.holds <> 1)
				do \form@updateUi()
				ret
			end if
			do me.holds.head()
			var obj: @Obj :: me.holds.get()
			var success: bool
			var value: int :: \form@editRbArX.getText().trim().toInt(&success)
			if(value < 0)
				do value :: 0
			end if
			if(success)
				do me.undo.recordBegin()
				do me.move(obj.name, value, obj.y, obj.width, obj.height, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		case %editRbArYOnKillFocus
			if(^me.holds <> 1)
				do \form@updateUi()
				ret
			end if
			do me.holds.head()
			var obj: @Obj :: me.holds.get()
			var success: bool
			var value: int :: \form@editRbArY.getText().trim().toInt(&success)
			if(value < 0)
				do value :: 0
			end if
			if(success)
				do me.undo.recordBegin()
				do me.move(obj.name, obj.x, value, obj.width, obj.height, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		case %editRbArWidthOnKillFocus
			var obj: @Obj
			if(^me.holds = 0)
				do obj :: me.root
			elif(^me.holds = 1)
				do me.holds.head()
				do obj :: me.holds.get()
			else
				do \form@updateUi()
				ret
			end if
			var success: bool
			var value: int :: \form@editRbArWidth.getText().trim().toInt(&success)
			var minValue: int
			var maxValue: int
			do obj.getMinMax(&minValue, &, &maxValue, &)
			if(value < minValue)
				do value :: minValue
			elif(value > maxValue)
				do value :: maxValue
			end if
			if(success)
				do me.undo.recordBegin()
				do me.move(obj =& me.root ?(null, obj.name), obj.x, obj.y, value, obj.height, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		case %editRbArHeightOnKillFocus
			var obj: @Obj
			if(^me.holds = 0)
				do obj :: me.root
			elif(^me.holds = 1)
				do me.holds.head()
				do obj :: me.holds.get()
			else
				do \form@updateUi()
				ret
			end if
			var success: bool
			var value: int :: \form@editRbArHeight.getText().trim().toInt(&success)
			var minValue: int
			var maxValue: int
			do obj.getMinMax(&, &minValue, &, &maxValue)
			if(value < minValue)
				do value :: minValue
			elif(value > maxValue)
				do value :: maxValue
			end if
			if(success)
				do me.undo.recordBegin()
				do me.move(obj =& me.root ?(null, obj.name), obj.x, obj.y, obj.width, value, true)
				do me.undo.recordEnd()
				do \form@paintDrawEditor()
			end if
			do \form@updateUi()
		end switch
	end func

	+*func loadImpl(xmlNode: xml@Node)
		var root: xml@Node :: xmlNode.findChild("root").firstChild()
		do me.root :: me.makeObj(root.getName())
		do me.root.load(root)
		var child: xml@Node :: xmlNode.findChild("children").firstChild()
		do me.nodes :: #list<@Obj>
		while(child <>& null)
			var node: @Obj :: me.makeObj(child.getName())
			do node.load(child)
			do me.nodes.add(node)
			do child :: child.next()
		end while
	end func

	+*func saveImpl(xmlNode: xml@Node)
		var root: xml@Node :: xmlNode.addChild("root")
		block
			var node: xml@Node :: root.addChild(me.root.kind())
			do me.root.save(node)
		end block
		var children: xml@Node :: xmlNode.addChild("children")
		do me.nodes.head()
		while(!me.nodes.term())
			var obj: @Obj :: me.nodes.get()
			var node: xml@Node :: children.addChild(obj.kind())
			do obj.save(node)
			do me.nodes.next()
		end while
	end func

	func makeObj(name: []char): @Obj
	end func

	func updateLt()
	end func

	const resizeArea: int :: 6

	enum Mode
		none
		put
		move
		resize
		sel
	end enum

	var src: [][]char
	var root: @Obj
	var nodes: list<@Obj>
	var holds: list<@Obj>
	var scrollOffsetX: int
	var scrollOffsetY: int
	var holdOffsetX: int
	var holdOffsetY: int
	var curOffsetX: int
	var curOffsetY: int
	var pageX: int
	var pageY: int
	var mode: Mode
	var updatingProp: bool

	func resizeObj(obj: @Obj, x: int, y: int)
		var width: int :: obj.width + x + me.pageX - me.holdOffsetX
		var height: int :: obj.height + y + me.pageY - me.holdOffsetY
		var minWidth: int
		var minHeight: int
		var maxWidth: int
		var maxHeight: int
		do obj.getMinMax(&minWidth, &minHeight, &maxWidth, &maxHeight)
		if(width < minWidth)
			do width :: minWidth
		elif(width > maxWidth)
			do width :: maxWidth
		end if
		if(height < minHeight)
			do height :: minHeight
		elif(height > maxHeight)
			do height :: maxHeight
		end if
		do me.move(obj =& me.root ?(null, obj.name), obj.x, obj.y, width, height, true)
	end func

	class UndoAr(\doc@UndoCmd)
		+*func cmd()
			do me.doc.undoImpl(me)
		end func
	end class

	class UndoArPut(UndoAr)
		+var parent: []char
		+var kind: []char
		+var name: []char
		+var x: int
		+var y: int
	end class

	class UndoArDel(UndoAr)
		+var name: []char
	end class

	class UndoArMove(UndoAr)
		+var name: []char
		+var x: int
		+var y: int
		+var width: int
		+var height: int
	end class

	class UndoArOrder(UndoAr)
		+var names: [][]char
	end class

	class UndoArRename(UndoAr)
		+var name: []char
		+var newName: []char
	end class

	class UndoArVisible(UndoAr)
		+var name: []char
		+var value: bool
	end class

	class UndoArProp(UndoAr)
		+var name: []char
		+var prop: []char
		+var value: []char
	end class

	func updateProp()
		do me.updatingProp :: true
		if(^me.holds >= 2)
			do \form@groupRbAr.setVisible(false)
		else
			var obj: @Obj
			if(^me.holds = 0)
				do obj :: me.root
			else
				do me.holds.head()
				do obj :: me.holds.get()
			end if
			var offsetX: int :: 0
			var offsetY: int :: 0
			var offsetWidth: int :: 0
			var offsetHeight: int :: 0
			if(me.mode = %put | me.mode = %resize)
				do offsetWidth :: me.curOffsetX - me.holdOffsetX
				do offsetHeight :: me.curOffsetY - me.holdOffsetY
			elif(me.mode = %move)
				do offsetX :: me.curOffsetX - me.holdOffsetX
				do offsetY :: me.curOffsetY - me.holdOffsetY
			end if
			do \form@groupRbAr.setVisible(true)
			do \form@groupRbAr.setRedraw(false)
			do \form@groupRbAr.setRedraw(true)
			do \form@editRbArName.setText(obj.name)
			do \form@chkRbArVisible.setChk(obj.visible)
			do \form@editRbArX.setText((obj.x + offsetX).toStr())
			do \form@editRbArY.setText((obj.y + offsetY).toStr())
			do \form@editRbArWidth.setText((obj.width + offsetWidth).toStr())
			do \form@editRbArHeight.setText((obj.height + offsetHeight).toStr())
		end if
		do me.updatingProp :: false
	end func

	func find(nodes: list<@Obj>, name: []char)
		do nodes.head()
		while(!nodes.term())
			if(nodes.get().name = name)
				ret
			end if
			do nodes.next()
		end while
	end func

	func put(parent: []char, kind: []char, name: []char, x: int, y: int, recordUndo: bool)
		if(recordUndo)
			var undo: UndoArDel :: #UndoArDel
			do undo.doc :: me
			do undo.name :: name
			var redo: UndoArPut :: #UndoArPut
			do redo.doc :: me
			do redo.parent :: parent
			do redo.kind :: kind
			do redo.name :: name
			do redo.x :: x
			do redo.y :: y
			do me.undo.add(undo, redo)
		end if
		var obj: @Obj :: me.makeObj(kind)
		var width: int
		var height: int
		do obj.getDefaultSize(&width, &height)
		do obj.init(name, true, x, y, width, height)
		if(parent =& null)
			do me.nodes.add(obj)
		else
			do me.find(me.nodes, parent)
			do me.nodes.ins(obj)
		end if
		do me.holds :: #list<@Obj>
		do me.holds.add(obj)
		do me.changed :: true
		do \form@updateUi()
	end func

	func del(name: []char, recordUndo: bool)
		do me.find(me.nodes, name)
		if(recordUndo)
			var obj: @Obj :: me.nodes.get()
			var parent: @Obj :: me.nodes.getOffset(-1)
			var undo: UndoArPut :: #UndoArPut
			do undo.doc :: me
			do undo.parent :: parent =& null ?(null, parent.name)
			do undo.kind :: obj.kind()
			do undo.name :: obj.name
			do undo.x :: obj.x
			do undo.y :: obj.y
			var redo: UndoArDel :: #UndoArDel
			do redo.doc :: me
			do redo.name :: obj.name
			do me.undo.add(undo, redo)
		end if
		do me.nodes.del()
		do me.changed :: true
		do \form@updateUi()
	end func

	func move(name: []char, x: int, y: int, width: int, height: int, recordUndo: bool)
		var obj: @Obj
		if(name =& null)
			do obj :: me.root
		else
			do me.find(me.nodes, name)
			do obj :: me.nodes.get()
		end if
		if(obj.x = x & obj.y = y & obj.width = width & obj.height = height)
			ret
		end if
		if(recordUndo)
			var undo: UndoArMove :: #UndoArMove
			do undo.doc :: me
			do undo.name :: name
			do undo.x :: obj.x
			do undo.y :: obj.y
			do undo.width :: obj.width
			do undo.height :: obj.height
			var redo: UndoArMove :: #UndoArMove
			do redo.doc :: me
			do redo.name :: name
			do redo.x :: x
			do redo.y :: y
			do redo.width :: width
			do redo.height :: height
			do me.undo.add(undo, redo)
		end if
		do obj.x :: x
		do obj.y :: y
		do obj.width :: width
		do obj.height :: height
		do me.changed :: true
		do \form@updateUi()
	end func

	func order(names: [][]char, recordUndo: bool)
		if(recordUndo)
			var oldNames: [][]char :: #[^me.nodes][]char
			do me.nodes.head()
			var i: int :: 0
			while(!me.nodes.term())
				do oldNames[i] :: me.nodes.get().name
				do i :+ 1
				do me.nodes.next()
			end while
			var undo: UndoArOrder :: #UndoArOrder
			do undo.doc :: me
			do undo.names :: oldNames
			var redo: UndoArOrder :: #UndoArOrder
			do redo.doc :: me
			do redo.names :: names
			do me.undo.add(undo, redo)
		end if
		var newNodes: list<@Obj> :: #list<@Obj>
		for i(0, ^names - 1)
			do me.find(me.nodes, names[i])
			do newNodes.add(me.nodes.get())
		end for
		do me.nodes :: newNodes
		do me.changed :: true
		do \form@updateUi()
	end func

	func rename(name: []char, newName: []char, recordUndo: bool)
		if(recordUndo)
			var undo: UndoArRename :: #UndoArRename
			do undo.doc :: me
			do undo.name :: newName
			do undo.newName :: name
			var redo: UndoArRename :: #UndoArRename
			do redo.doc :: me
			do redo.name :: name
			do redo.newName :: newName
			do me.undo.add(undo, redo)
		end if
		do me.find(me.nodes, name)
		do me.nodes.get().name :: newName
		do me.changed :: true
		do \form@updateUi()
	end func

	func visible(name: []char, value: bool, recordUndo: bool)
		var obj: @Obj
		if(name =& null)
			do obj :: me.root
		else
			do me.find(me.nodes, name)
			do obj :: me.nodes.get()
		end if
		if(recordUndo)
			var undo: UndoArVisible :: #UndoArVisible
			do undo.doc :: me
			do undo.name :: name
			do undo.value :: obj.visible
			var redo: UndoArVisible :: #UndoArVisible
			do redo.doc :: me
			do redo.name :: name
			do redo.value :: value
			do me.undo.add(undo, redo)
		end if
		do obj.visible :: value
		do me.changed :: true
		do \form@updateUi()
	end func

	func prop(name: []char, prop: []char, value: []char, recordUndo: bool)
	end func
end class

+class Obj()
	+*func cmp(t: kuin@Class): int
		ret t =& me ?(0, 1)
	end func

	+func load(node: xml@Node)
		do me.name :: node.getAttr("name")
		do me.visible :: node.getAttr("visible") = "true"
		do me.x :: node.getAttr("x").toInt(&)
		do me.y :: node.getAttr("y").toInt(&)
		do me.width :: node.getAttr("width").toInt(&)
		do me.height :: node.getAttr("height").toInt(&)
		do me.props :: #dict<[]char, []char>
		var propsNames: [][]char :: me.propsNames()
		for i(0, ^propsNames - 1)
			do me.props.add(propsNames[i], node.getAttr(propsNames[i]))
		end for
	end func

	+func save(node: xml@Node)
		do node.setAttr("name", me.name)
		do node.setAttr("visible", me.visible ?("true", "false"))
		do node.setAttr("x", me.x.toStr())
		do node.setAttr("y", me.y.toStr())
		do node.setAttr("width", me.width.toStr())
		do node.setAttr("height", me.height.toStr())
		var propsNames: [][]char :: me.propsNames()
		for i(0, ^propsNames - 1)
			do node.setAttr(propsNames[i], me.props.get(propsNames[i], &))
		end for
	end func

	+func draw(x: float, y: float, width: float, height: float)
	end func

	+func getMinMax(minWidth: &int, minHeight: &int, maxWidth: &int, maxHeight: &int)
		do minWidth :: 10
		do minHeight :: 10
		do maxWidth :: lib@intMax
		do maxHeight :: lib@intMax
	end func

	+func getDefaultSize(width: &int, height: &int)
		do width :: 10
		do height :: 10
	end func

	+func kind(): []char
	end func

	+func init(name: []char, visible: bool, x: int, y: int, width: int, height: int)
		do me.name :: name
		do me.visible :: visible
		do me.x :: x
		do me.y :: y
		do me.width :: width
		do me.height :: height
		do me.props :: #dict<[]char, []char>
	end func

	func propsNames(): [][]char
	end func

	+var name: []char
	+var visible: bool
	+var x: int
	+var y: int
	+var width: int
	+var height: int
	+var props: dict<[]char, []char>
end class

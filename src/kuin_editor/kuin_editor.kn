; Kuin Editor
; (C)Kuina-chan

func [d0917.knd, InitCompiler] initCompiler()
end func

func [d0917.knd, FinCompiler] finCompiler()
end func

func [d0917.knd, BuildMem] build(path: []char, funcGetSrc: func<([]char): [][]char>, sysDir: []char, output: []char, icon: []char, rls_: bool, env: []char, funcLog: func<([][]char, int, int)>, lang: int): bool
end func

func [d0917.knd, Interpret1] interpret1(src: [][]char, color: [][]bit8)
end func

func [d0917.knd, Interpret2] interpret2(path: []char, funcGetSrc: func<([]char): [][]char>, sysDir: []char, env: []char, funcLog: func<([][]char, int, int)>, lang: int)
end func

func [d0917.knd, Version] version(major: &int, minor: &int, micro: &int)
end func

func [d0917.knd, ResetMemAllocator] resetMemAllocator()
end func

func [d0917.knd, GetHint] getHint(src: []char, row: int, col: int): []char
end func

func [d0917.knd, RunDbg] runDbg(name: []char, cmdLine: []char, idleFunc: func<()>, eventFunc: func<(int, []char): int>): bool
end func

var wndMain: wnd@Wnd
var treeItem: wnd@Tree
var listInfo: wnd@List
var editFile: wnd@Edit
var drawEditor: wnd@Draw
var scrollXSrc: wnd@ScrollX
var scrollYSrc: wnd@ScrollY
var editHint: wnd@EditMulti
var editLog: wnd@EditMulti
var btnCompile: wnd@Btn
var groupEnv: wnd@Group
var radioEnvWnd: wnd@Radio
var radioEnvCui: wnd@Radio
var btnRls: wnd@Btn
var listFile: wnd@List
var menuMain: wnd@Menu
var popupMainEdit: wnd@Popup
var popupMainFile: wnd@Popup
var popupMainBuild: wnd@Popup
var popupMainHelp: wnd@Popup
var wndDlg: wnd@Wnd
var wndDlgResultFile: []char
var wndDlgResultType: int
var wndDlgEditFile: wnd@Edit
var wndDlgListType: wnd@List

class Undo()
end class

class Pos()
	+var src: []char
	+var row: int
	+var col: int

	+*func cmp(t: Pos): int
		var result: int :: lib@cmp(me.src, t.src)
		if(result <> 0)
			ret result
		end if
		do result :: me.row - t.row
		if(result <> 0)
			ret result
		end if
		ret me.col - t.col
	end func
end class

class ListInfoItem()
	+var text: []char
	+var pos: @Pos

	+*func cmp(t: ListInfoItem): int
		ret me.pos.cmp(t.pos)
	end func
end class

class DocumentsClass()
	+var documents: dict<[]char, @Document>
end class

class Document()
	+func init(src: [][]char)
		do me.initVars()
	end func

	+func getSrc(): [][]char
	end func

	+func draw(width: int, height: int)
	end func

	+func mouseDownL(x: int, y: int)
	end func

	+func mouseUpL(x: int, y: int)
	end func

	+func mouseMove(x: int, y: int)
	end func

	+func focus(isFocus: bool)
	end func

	+func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	end func

	+func keyChar(key: char)
	end func

	+func scrollX(pos: int)
	end func

	+func scrollY(pos: int)
	end func

	+func wheelX(wheel: int)
	end func

	+func wheelY(wheel: int)
	end func

	+func cmdUndo()
	end func

	+func cmdRedo()
	end func

	+func cmdCut()
	end func

	+func cmdCopy()
	end func

	+func cmdPaste()
	end func

	+func cmdDel()
	end func

	+func cmdSelAll()
	end func

	+func undo()
		if(me.undoBuf[me.undoPtrPrev(me.undoPtr)] =& null)
			ret
		end if
		while(true)
			do me.undoPtr :: me.undoPtrPrev(me.undoPtr)
			if(me.undoBuf[me.undoPtr] =& null)
				ret
			end if
			do me.undoImpl(me.undoBuf[me.undoPtr])
		end while
	end func

	+func redo()
		if(me.redoBuf[me.undoPtrNext(me.undoPtr)] =& null)
			ret
		end if
		while(true)
			do me.undoPtr :: me.undoPtrNext(me.undoPtr)
			if(me.redoBuf[me.undoPtr] =& null)
				ret
			end if
			do me.undoImpl(me.redoBuf[me.undoPtr])
		end while
	end func

	const undoBufSize: int :: 1024

	var undoBuf: []@Undo
	var redoBuf: []@Undo
	var undoPtr: int
	+var changed: bool

	func initVars()
		do me.undoBuf :: #[undoBufSize]@Undo
		do me.redoBuf :: #[undoBufSize]@Undo
		do me.undoPtr :: 0
		do me.changed :: false
	end func

	func incUndoPtr()
		do me.undoPtr :: me.undoPtrNext(me.undoPtr)
	end func

	func addUndo(undo2: @Undo)
		do me.undoBuf[me.undoPtr] :: undo2
	end func

	func addRedo(redo2: @Undo)
		do me.redoBuf[me.undoPtr] :: redo2
	end func

	func addUndoMark()
		do me.undoPtr :: me.undoPtrNext(me.undoPtr)
		var next: int :: me.undoPtrNext(me.undoPtr)
		do me.undoBuf[me.undoPtr] :: null
		do me.undoBuf[next] :: null
		do me.redoBuf[me.undoPtr] :: null
		do me.redoBuf[next] :: null
	end func

	func undoPtrPrev(ptr: int): int
		ret ptr = 0 ?(undoBufSize - 1, ptr - 1)
	end func

	func undoPtrNext(ptr: int): int
		ret ptr = undoBufSize - 1 ?(0, ptr + 1)
	end func

	func undoImpl(undo2: @Undo)
	end func
end class

class DocumentSrc(@Document)
	+*func init(src: [][]char)
		do me.initVars()
		do me.src :: #Src
		if(src =& null | ^src = 0)
			do me.src.src :: [""]
			do me.src.color :: [#[0]bit8]
		else
			do me.src.src :: src
			do me.src.color :: #[^src][]bit8
			for i(0, ^src - 1)
				do me.src.color[i] :: #[^src[i]]bit8
			end for
		end if
		do me.pageX :: 0
		do me.pageY :: 0
		do me.cursorX :: 0
		do me.cursorY :: 0
		do me.areaX :: -1
		do me.areaY :: -1
		do me.lineNumberWidth :: 0
		do me.interpreted :: false
	end func

	+*func getSrc(): [][]char
		ret me.src.src
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, @colorBack)
		var lineX: float :: (me.lineNumberWidth - 2) $ float
		do draw@line(lineX, 0.0, lineX, height $ float, colorLineNumber)
		for i(0, ^me.src.src - 1)
			var y: float :: (i * @cellHeight) $ float
			if(y < -@cellHeight $ float | y >= (height + @cellHeight) $ float)
				skip i
			end if
			var str: []char :: (me.pageY + i + 1).toStr()
			do @font.draw((me.lineNumberWidth - (^str + 1) * @cellWidth + @cellWidth / 2) $ float, y, str, colorLineNumber)
		end for

		var areaX1: int :: me.areaX
		var areaY1: int :: me.areaY
		var areaX2: int :: me.cursorX
		var areaY2: int :: me.cursorY
		if(me.areaSelected() & (areaY1 > areaY2 | areaY1 = areaY2 & areaX1 > areaX2))
			do areaX1 :$ areaX2
			do areaY1 :$ areaY2
		end if
		for i(0, height / @cellHeight)
			if(me.pageY + i >= ^me.src.src)
				break i
			end if
			var str: []char :: me.src.src[me.pageY + i]
			var left: int :: me.lineNumberWidth - me.pageX * @cellWidth
			var x: int :: 0
			for j(0, ^str)
				assert j = ^str | str[j] <> 16#01 $ char & str[j] <> '\n'
				var x2: int :: left + x * @cellWidth
				if(x2 >= width)
					break j
				end if
				if(x2 >= me.lineNumberWidth)
					var inArea: bool :: false
					if(me.areaSelected())
						var areaX3: int :: j
						var areaY3: int :: me.pageY + i
						if (areaY3 < areaY1 | areaY2 < areaY3)
							; Do nothing.
						elif(areaY1 < areaY3 & areaY3 < areaY2)
							do inArea :: true
						elif(areaY1 = areaY2)
							do inArea :: areaX1 <= areaX3 & areaX3 < areaX2
						elif(areaY3 = areaY1)
							do inArea :: areaX1 <= areaX3
						else
							assert areaY3 = areaY2
							do inArea :: areaX3 < areaX2
						end if
					end if
					var textX: float :: x2 $ float
					var textY: float :: (i * @cellHeight) $ float
					if(j = ^str)
						if(inArea)
							do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, colorAreaBack)
						end if
						; TODO: Return mark.
					elif(inArea)
						do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, colorAreaBack)
						do @font.draw(textX, textY, str[j].toStr(), draw@white)
					elif(me.src.color[me.pageY + i][j].and(16#80b8) <> 0 $ @CharColor $ bit8)
						do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, colorErrBack)
						do @font.draw(textX, textY, str[j].toStr(), draw@white)
					else
						do @font.draw(textX, textY, str[j].toStr(), @srcCharColor[me.src.color[me.pageY + i][j].and(16#7Fb8) $ int])
					end if
				end if
				if(j <> ^str)
					do x :+ me.charWidth(str[j], x)
				end if
			end for
		end for
	end func

	+*func mouseDownL(x: int, y: int)
		do me.setArea(wnd@key(%shift) ?(%shift $ wnd@ShiftCtrl, %none))
		do me.mousePosToCharPos(x, y)
		do me.refreshCursor(false, true)
		if(!me.areaSelected())
			do me.areaX :: me.cursorX
			do me.areaY :: me.cursorY
		end if
		do @drawEditor.paint()
	end func

	+*func mouseUpL(x: int, y: int)
		do me.refreshCursor(false, true)
	end func

	+*func mouseMove(x: int, y: int)
		if(@drag)
			do me.mousePosToCharPos(x, y)
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end func

	+*func focus(isFocus: bool)
		if(isFocus)
			do @drawEditor.showCaret(@cellHeight, @font)
			do me.refreshCursor(false, true)
		else
			do @drawEditor.hideCaret()
		end if
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		switch(key)
		case %bs
			if (@lockingEditor)
				ret
			end if
			if(shiftCtrl = %none)
				if(me.areaSelected())
					do me.delAreaStr()
				else
					do me.bs(me.cursorX, me.cursorY, 1, true)
				end if
				do me.addUndoMark()
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %tab
			switch(shiftCtrl)
			case %none
				if (@lockingEditor)
					ret
				end if
				if(!me.areaSelected())
					do me.ins(me.cursorX, me.cursorY, "\t", true)
					do me.addUndoMark()
					do me.refreshCursor(false, true)
					do @drawEditor.paint()
				else
					do me.indentAreaStr()
					do me.refreshCursor(false, true)
					do @drawEditor.paint()
				end if
			case %shift
				if (@lockingEditor)
					ret
				end if
				if(me.areaSelected())
					do me.unindentAreaStr()
					do me.refreshCursor(false, true)
					do @drawEditor.paint()
				end if
			end switch
		case %enter
			if (@lockingEditor)
				ret
			end if
			if(shiftCtrl = %none)
				if(me.areaSelected())
					do me.delAreaStr()
				end if
				block
					var str: []char :: "\n"
					for i(0, ^me.src.src[me.cursorY] - 1)
						if(me.src.src[me.cursorY][i] = '\t')
							do str :~ "\t"
						else
							break i
						end if
					end for
					do me.ins(me.cursorX, me.cursorY, str, true)
				end block
				do me.addUndoMark()
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %pageUp
			if(shiftCtrl <> %ctrl)
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				var width: int
				var height: int
				do @drawEditor.getSize(&width, &height)
				do me.cursorY :- height / @cellHeight
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %pageDown
			if(shiftCtrl <> %ctrl)
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				var width: int
				var height: int
				do @drawEditor.getSize(&width, &height)
				do me.cursorY :+ height / @cellHeight
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %end_
			do me.setArea(shiftCtrl)
			do me.cursorX :: lib@intMax
			if(shiftCtrl.and(%ctrl) <> %none)
				do me.cursorY :: lib@intMax
			end if
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		case %home
			do me.setArea(shiftCtrl)
			do me.cursorX :: 0
			if(shiftCtrl.and(%ctrl) <> %none)
				do me.cursorY :: 0
			end if
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		case %left
			if(shiftCtrl = %ctrl)
				do me.scrollPageX(-1)
			else
				do me.setArea(shiftCtrl)
				do me.cursorX :- 1
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %up
			if(shiftCtrl = %ctrl)
				do me.scrollPageY(-1)
			else
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				do me.cursorY :- 1
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %right
			if(shiftCtrl = %ctrl)
				do me.scrollPageX(1)
			else
				do me.setArea(shiftCtrl)
				do me.cursorX :+ 1
				do me.refreshCursor(true, true)
				do @drawEditor.paint()
			end if
		case %down
			if(shiftCtrl = %ctrl)
				do me.scrollPageY(1)
			else
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				do me.cursorY :+ 1
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %ins
			; TODO: Insert mode.
		end switch
	end func

	+*func keyChar(key: char)
		if (@lockingEditor)
			ret
		end if
		if(key = '\t' | me.charWidth(key, 0) = 0)
			ret
		end if
		if(me.areaSelected())
			do me.delAreaStr()
		end if
		do me.ins(me.cursorX, me.cursorY, [key], true)
		do me.addUndoMark()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos
		do me.refreshCursor(false, false)
		do @drawEditor.paint()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos
		do me.refreshCursor(false, false)
		do @drawEditor.paint()
	end func

	+*func wheelX(wheel: int)
		do me.scrollPageX(wheel)
	end func

	+*func wheelY(wheel: int)
		do me.scrollPageY(wheel * 3)
	end func

	+*func cmdUndo()
		if (@lockingEditor)
			ret
		end if
		if(me.areaSelected())
			do me.areaX :: -1
		end if
		do me.undo()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func cmdRedo()
		if (@lockingEditor)
			ret
		end if
		if(me.areaSelected())
			do me.areaX :: -1
		end if
		do me.redo()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func cmdCut()
		if (@lockingEditor)
			ret
		end if
		if(me.areaSelected())
			do me.copyAreaStr()
			do me.delAreaStr()
			do me.addUndoMark()
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end func

	+*func cmdCopy()
		if(me.areaSelected())
			do me.copyAreaStr()
		end if
	end func

	+*func cmdPaste()
		if (@lockingEditor)
			ret
		end if
		var str: []char :: wnd@getClipboardStr()
		if(str <>& null)
			if(me.areaSelected())
				do me.delAreaStr()
			end if
			do me.ins(me.cursorX, me.cursorY, str, true)
			do me.addUndoMark()
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end func

	+*func cmdDel()
		if (@lockingEditor)
			ret
		end if
		if(me.areaSelected())
			do me.delAreaStr()
		else
			do me.del(me.cursorX, me.cursorY, 1, true)
		end if
		do me.addUndoMark()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func cmdSelAll()
		do me.areaX :: 0
		do me.areaY :: 0
		do me.cursorX :: lib@intMax
		do me.cursorY :: lib@intMax
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+func showHint()
		var x: int :: me.cursorX
		while(x > 0 & (me.src.src[me.cursorY][x] = ' ' | me.src.src[me.cursorY][x] = '\t'))
			do x :- 1
		end while
		var srcName: []char :: @srcNameToInternalName(@getDocumentName(@curDocument))
		if(^me.src.src[me.cursorY] > 0 & me.src.src[me.cursorY][x] <> ' ' & me.src.src[me.cursorY][x] <> '\t')
			if(srcName <>& null)
				var hint: []char :: ##@getHint(srcName, me.cursorY + 1, x)
				if(hint =& null)
					do hint :: ""
				end if
				if(@textHint <> hint)
					do @textHint :: hint
					do @updateLog()
				end if
			end if
		else
			if(@textHint <> "")
				do @textHint :: ""
				do @updateLog()
			end if
		end if
		do me.getFuncHint(srcName, x, me.cursorY)
	end func

	+func move(col: int, row: int)
		do me.cursorX :: col
		do me.cursorY :: row
		do me.refreshCursor(false, true)
	end func

	const colorLineNumber: int :: 16#FFFF7F7F
	const colorAreaBack: int :: 16#FF808080
	const colorErrBack: int :: 16#FFFF3333

	class Src()
		+var src: [][]char
		+var color: [][]bit8
	end class

	enum UndoKind
		ins
		bs
		del
	end enum

	class UndoSrc(@Undo)
		+var kind: UndoKind
		+var x: int
		+var y: int
		+var str: []char
	end class

	+var src: Src
	var pageX: int
	var pageY: int
	var cursorX: int
	var cursorY: int
	var areaX: int
	var areaY: int
	var lineNumberWidth: int
	+var interpreted: bool

	func areaSelected(): bool
		ret me.areaX <> -1 & (me.areaX <> me.cursorX | me.areaY <> me.cursorY)
	end func

	func charWidth(c: char, x: int): int
		if(c = '\t')
			ret 4 - x % 4
		elif(c $ int <= 16#1F)
			ret 0
		elif(c $ int <= 16#7E)
			ret 1
		elif(c $ int <= 16#A0)
			ret 0
		end if
		ret 2
	end func

	func setArea(shiftCtrl: wnd@ShiftCtrl)
		if(shiftCtrl.and(%shift) <> %none)
			if(!me.areaSelected())
				do me.areaX :: me.cursorX
				do me.areaY :: me.cursorY
			end if
		else
			do me.areaX :: -1
		end if
	end func

	func mousePosToCharPos(mouseX: int, mouseY: int)
		do me.cursorY :: me.pageY + mouseY / @cellHeight
		if(me.cursorY >= ^me.src.src)
			do me.cursorX :: 0
			ret
		end if
		var left: int :: me.lineNumberWidth - me.pageX * @cellWidth
		var x: int :: 0
		for i(0, ^me.src.src[me.cursorY] - 1)
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], x)
			if(mouseX < left + (x + charWidth2) * @cellWidth)
				do me.cursorX :: i
				ret
			end if
			do x :+ charWidth2
		end for
		do me.cursorX :: ^me.src.src[me.cursorY]
	end func

	func refreshCursor(moveRight: bool, refreshScroll: bool)
		var scrWidth: int
		var scrHeight: int
		do @drawEditor.getSize(&scrWidth, &scrHeight)
		do me.lineNumberWidth :: @cellWidth * (log10(^me.src.src) + 1)

		if(me.cursorX < 0)
			do me.cursorX :: lib@intMax
			do me.cursorY :- 1
		end if
		if(me.cursorY < 0)
			do me.cursorX :: 0
			do me.cursorY :: 0
		end if
		if(me.cursorY > ^me.src.src - 1)
			do me.cursorY :: ^me.src.src - 1
			do me.cursorX :: ^me.src.src[me.cursorY]
		else
			if(me.cursorX > ^me.src.src[me.cursorY])
				if(moveRight & me.cursorY <> ^me.src.src - 1)
					do me.cursorX :: 0
					do me.cursorY :+ 1
				else
					do me.cursorX :: ^me.src.src[me.cursorY]
				end if
			end if
		end if
		if(!@drag & me.areaX = me.cursorX & me.areaY = me.cursorY)
			do me.areaX :: -1
		end if

		if(refreshScroll)
			var paddingX: int :: (me.lineNumberWidth + 17) / @cellWidth + 1
			const paddingY: int :: 17 / @cellHeight + 1
			if(me.pageY > me.cursorY)
				do me.pageY :: me.cursorY
			end if
			if(me.pageY < me.cursorY - scrHeight / @cellHeight + paddingY)
				do me.pageY :: me.cursorY - scrHeight / @cellHeight + paddingY
			end if
			do @scrollYSrc.setState(0, ^me.src.src - 1 + paddingY, scrHeight / @cellHeight, me.pageY)
			var maxX: int :: 0
			for i(0, scrHeight / @cellHeight + 1)
				if(me.pageY + i >= ^me.src.src)
					break i
				end if
				var x: int :: 0
				var str: []char :: me.src.src[me.pageY + i]
				for j(0, ^str - 1)
					do x :+ me.charWidth(str[j], x)
				end for
				if(maxX < x)
					do maxX :: x
				end if
			end for
			block
				var x: int :: 0
				for i(0, ^me.src.src[me.cursorY] - 1)
					if(i >= me.cursorX)
						break i
					end if
					do x :+ me.charWidth(me.src.src[me.cursorY][i], x)
				end for
				if(me.pageX > x)
					do me.pageX :: x
				end if
				if(me.pageX < x - scrWidth / @cellWidth + paddingX)
					do me.pageX :: x - scrWidth / @cellWidth + paddingX
				end if
			end block
			do @scrollXSrc.setState(0, maxX - 1 + paddingX, scrWidth / @cellWidth, me.pageX)
		end if

		block
			var x: int :: 0
			var str: []char :: me.src.src[me.cursorY]
			for i(0, me.cursorX - 1)
				do x :+ me.charWidth(str[i], x)
			end for
			do x :: me.lineNumberWidth + (x - me.pageX) * @cellWidth
			var y: int :: (me.cursorY - me.pageY) * @cellHeight
			if(x + 2 <= 0 | scrWidth - 17 <= x | y + @cellHeight <= 0 | scrHeight - 17 <= y)
				do @drawEditor.moveCaret(-1, -1)
			else
				do @drawEditor.moveCaret(x, y)
			end if
		end block

		do @setDirtyHint()

		func log10(n: int): int
			var result: int :: 0
			var m: int :: 1
			while(n >= m)
				do m :* 10
				do result :+ 1
			end while
			ret result
		end func
	end func

	func getAbsoluteX(): int
		if(me.cursorY < 0 | ^me.src.src <= me.cursorY)
			ret 0
		end if
		var absoluteX: int :: 0
		for i(0, me.cursorX - 1)
			if(i >= ^me.src.src[me.cursorY])
				break i
			end if
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], absoluteX)
			do absoluteX :+ charWidth2
		end for
		ret absoluteX
	end func

	func setAbsoluteX(absoluteX: int)
		if(me.cursorY < 0 | ^me.src.src <= me.cursorY)
			ret
		end if
		var x: int :: 0
		do me.cursorX :: 0
		for i(0, ^me.src.src[me.cursorY] - 1)
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], x)
			if(x + charWidth2 > absoluteX)
				break i
			end if
			do x :+ charWidth2
			do me.cursorX :+ 1
		end for
	end func

	func copyAreaStr()
		assert me.areaSelected()
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		var str: []char
		if(y1 = y2)
			do str :: me.src.src[y1].sub(x1, x2 - x1)
		else
			do str :: me.src.src[y1].sub(x1, -1) ~ "\n"
			for i(y1 + 1, y2 - 1)
				do str :~ me.src.src[i] ~ "\n"
			end for
			do str :~ me.src.src[y2].sub(0, x2)
		end if
		do wnd@setClipboardStr(str)
	end func

	func delAreaStr()
		assert me.areaSelected()
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		var len: int
		if(y1 = y2)
			do len :: x2 - x1
		else
			do len :: ^me.src.src[y1] - x1 + 1
			for i(y1 + 1, y2 - 1)
				do len :+ ^me.src.src[i] + 1
			end for
			do len :+ x2
		end if
		do me.cursorX :: x1
		do me.cursorY :: y1
		do me.del(me.cursorX, me.cursorY, len, true)
		do me.areaX :: -1
	end func

	func indentAreaStr()
		assert me.areaSelected()
		var oldAreaX: int :: me.areaX
		var oldAreaY: int :: me.areaY
		var oldCursorX: int :: me.cursorX
		var oldCursorY: int :: me.cursorY
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		var dirty: bool :: false
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		for i(y1, y2)
			if(^me.src.src[i] <> 0)
				do me.ins(0, i, "\t", true)
				do dirty :: true
				if(i = oldAreaY)
					do oldAreaX :+ 1
				end if
				if(i = oldCursorY)
					do oldCursorX :+ 1
				end if
			end if
		end for
		if(dirty)
			do me.addUndoMark()
		end if
		do me.areaX :: oldAreaX
		do me.areaY :: oldAreaY
		do me.cursorX :: oldCursorX
		do me.cursorY :: oldCursorY
	end func

	func unindentAreaStr()
		assert me.areaSelected()
		var oldAreaX: int :: me.areaX
		var oldAreaY: int :: me.areaY
		var oldCursorX: int :: me.cursorX
		var oldCursorY: int :: me.cursorY
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		var dirty: bool :: false
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		for i(y1, y2)
			if(^me.src.src[i] > 0 & me.src.src[i][0] = '\t')
				do me.del(0, i, 1, true)
				do dirty :: true
				if(i = oldAreaY & oldAreaX > 0)
					do oldAreaX :- 1
				end if
				if(i = oldCursorY & oldCursorX > 0)
					do oldCursorX :- 1
				end if
			end if
		end for
		if(dirty)
			do me.addUndoMark()
		end if
		do me.areaX :: oldAreaX
		do me.areaY :: oldAreaY
		do me.cursorX :: oldCursorX
		do me.cursorY :: oldCursorY
	end func

	func ins(x: int, y: int, str: []char, recordUndo: bool)
		if(recordUndo)
			do me.incUndoPtr()
			var redo: UndoSrc :: #UndoSrc
			do redo.kind :: %ins
			do redo.x :: x
			do redo.y :: y
			do redo.str :: str
			do me.addRedo(redo)
		end if
		for i(0, ^str - 1)
			if(str[i] = '\n')
				var line: []char :: me.src.src[y].sub(x, -1)
				do me.src.src[y] :: me.src.src[y].sub(0, x)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
				do me.src.src :: me.src.src.sub(0, y + 1) ~ [line] ~ me.src.src.sub(y + 1, -1)
				do me.src.color :: me.src.color.sub(0, y + 1) ~ [#[^line]bit8] ~ me.src.color.sub(y + 1, -1)
				do x :: 0
				do y :+ 1
			else
				do me.src.src[y] :: me.src.src[y].sub(0, x) ~ str[i].toStr() ~ me.src.src[y].sub(x, -1)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
				do x :+ 1
			end if
		end for
		if(recordUndo)
			var undo: UndoSrc :: #UndoSrc
			do undo.kind :: %bs
			do undo.x :: x
			do undo.y :: y
			do undo.str :: (^str).toStr()
			do me.addUndo(undo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do @setDirtyInterpret()
		do me.changed :: true
	end func

	func bs(x: int, y: int, len: int, recordUndo: bool)
		if(recordUndo)
			do me.incUndoPtr()
			var redo: UndoSrc :: #UndoSrc
			do redo.kind :: %bs
			do redo.x :: x
			do redo.y :: y
			do redo.str :: len.toStr()
			do me.addRedo(redo)
		end if
		var undoStr: []char :: ""
		for(1, len)
			if(x = 0)
				if(y <> 0)
					do undoStr :: "\n" ~ undoStr
					var x2: int :: ^me.src.src[y - 1]
					do me.src.src[y - 1] :~ me.src.src[y]
					do me.src.color[y - 1] :: #[^me.src.src[y - 1]]bit8
					do me.src.src :: me.src.src.sub(0, y) ~ me.src.src.sub(y + 1, -1)
					do me.src.color :: me.src.color.sub(0, y) ~ me.src.color.sub(y + 1, -1)
					do y :- 1
					do x :: x2
				end if
			else
				do undoStr :: me.src.src[y][x - 1].toStr() ~ undoStr
				do me.src.src[y] :: me.src.src[y].sub(0, x - 1) ~ me.src.src[y].sub(x, -1)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
				do x :- 1
			end if
		end for
		if(recordUndo)
			var undo: UndoSrc :: #UndoSrc
			do undo.kind :: %ins
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.addUndo(undo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do @setDirtyInterpret()
		do me.changed :: true
	end func

	func del(x: int, y: int, len: int, recordUndo: bool)
		if(recordUndo)
			do me.incUndoPtr()
			var redo: UndoSrc :: #UndoSrc
			do redo.kind :: %del
			do redo.x :: x
			do redo.y :: y
			do redo.str :: len.toStr()
			do me.addRedo(redo)
		end if
		var undoStr: []char :: ""
		for(1, len)
			if(x = ^me.src.src[y])
				if(y <> ^me.src.src - 1)
					do undoStr :~ "\n"
					do me.src.src[y] :~ me.src.src[y + 1]
					do me.src.color[y] :: #[^me.src.src[y]]bit8
					do me.src.src :: me.src.src.sub(0, y + 1) ~ me.src.src.sub(y + 2, -1)
					do me.src.color :: me.src.color.sub(0, y + 1) ~ me.src.color.sub(y + 2, -1)
				end if
			else
				do undoStr :~ me.src.src[y][x].toStr()
				do me.src.src[y] :: me.src.src[y].sub(0, x) ~ me.src.src[y].sub(x + 1, -1)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
			end if
		end for
		if(recordUndo)
			var undo: UndoSrc :: #UndoSrc
			do undo.kind :: %ins
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.addUndo(undo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do @setDirtyInterpret()
		do me.changed :: true
	end func

	*func undoImpl(undo2: @Undo)
		var undo3: UndoSrc :: undo2 $ UndoSrc
		switch(undo3.kind)
		case %ins
			do me.ins(undo3.x, undo3.y, undo3.str, false)
		case %bs
			block
				var n: int
				do undo3.str.toInt(&n)
				do me.bs(undo3.x, undo3.y, n, false)
			end block
		case %del
			block
				var n: int
				do undo3.str.toInt(&n)
				do me.del(undo3.x, undo3.y, n, false)
			end block
		default
			assert false
		end switch
	end func

	func getFuncHint(srcName: []char, x: int, y: int)
		var charColor: bit8 :: me.src.color[y][x]
		if(x > 0)
			do x :- 1
		end if
		switch(charColor $ @CharColor)
		case %char_, %str, %lineComment, %comment
			while(x > 0 & me.src.color[y][x].and(16#7Fb8) = charColor)
				do x :- 1
			end while
		end switch
		var parenthesisNum: int :: 0
		var commaNum: int :: 0
		while(x > 0)
			switch(me.src.src[y][x])
			case '('
				do parenthesisNum :- 1
				if(parenthesisNum < 0)
					while(x > 0 & (me.src.src[y][x - 1] = ' ' | me.src.src[y][x - 1] = '\t'))
						do x :- 1
					end while
					if(x > 0)
						switch color(me.src.color[y][x - 1].and(16#7Fb8) $ @CharColor)
						case %identifier, %global, %reserved
							do x :- 1
							var hint: []char :: ##@getHint(srcName, y + 1, x)
							if(hint =& null)
								do hint :: ""
							else
								do hint :: "func: " ~ hint
							end if
							if(@textFunc <> hint)
								do @textFunc :: hint
								do @updateLog()
							end if
							ret
						default
							do parenthesisNum :: 0
							do commaNum :: 0
						end switch
					end if
				end if
			case ')'
				do parenthesisNum :+ 1
			case ','
				if(parenthesisNum = 0)
					do commaNum :+ 1
				end if
			default
				switch color(me.src.color[y][x].and(16#7Fb8) $ @CharColor)
				case %char_, %str, %lineComment, %comment
					while(x > 0 & me.src.color[y][x - 1].and(16#7Fb8) = color $ bit8)
						do x :- 1
					end while
				end switch
			end switch
			do x :- 1
		end while
		if(@textFunc <> "")
			do @textFunc :: ""
			do @updateLog()
		end if
	end func

	func scrollPageX(wheel: int)
		do me.pageX :+ wheel
		; TODO: me.pageX >= ?
		if(me.pageX < 0)
			do me.pageX :: 0
		end if
		do me.refreshCursor(false, false)
		do @drawEditor.paint()
	end func

	func scrollPageY(wheel: int)
		do me.pageY :+ wheel
		const paddingY: int :: 17 / @cellHeight + 1
		var scrWidth: int
		var scrHeight: int
		do @drawEditor.getSize(&scrWidth, &scrHeight)
		if (me.pageY >= ^me.src.src - scrHeight / @cellHeight + paddingY)
			do me.pageY :: ^me.src.src - scrHeight / @cellHeight + paddingY
		end if
		if (me.pageY < 0)
			do me.pageY :: 0
		end if
		do me.refreshCursor(false, false)
		do @drawEditor.paint()
	end func
end class

class DocumentArBase(@Document)
	+*func init(src: [][]char)
		do me.initVars()
		do me.obj2dRoot :: #@Obj2dRoot
		do me.obj2dRoot.init("", 0, 0, 1600, 900)
		do me.pageX :: 0
		do me.pageY :: 0
		do me.mode :: %none
		do me.hold :: null

		if(src <>& null)
			assert src[0].sub(0, 6) = ";;[ar_"
			var ptr: int :: 6
			while(src[0][ptr] <> ']')
				do ptr :+ 1
			end while
			do ptr :+ 1
			do me.initFromMeta(src[0], &ptr)
		end if
	end func

	+*func getSrc(): [][]char
		var meta: []char :: ";;[ar_" ~ me.getMeta() ~ "]" ~ getMetaRecursion(me.obj2dRoot)
		do me.src :: [meta] ~ getSrcRecursion(me.obj2dRoot)
		ret me.src

		func getMetaRecursion(obj: @Obj2d): []char
			var meta: []char :: obj.writeMeta()
			do obj.children.head()
			while(!obj.children.term())
				do meta :~ getMetaRecursion(obj.children.get())
				do obj.children.next()
			end while
			ret meta
		end func

		func getSrcRecursion(obj: @Obj2d): [][]char
			var src: [][]char :: obj.getSrc()
			do obj.children.head()
			while(!obj.children.term())
				do src :~ getSrcRecursion(obj.children.get())
				do obj.children.next()
			end while
			ret src
		end func
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, @colorBack)
		do drawRecursion(me.obj2dRoot, me.pageX, me.pageY, me.hold)

		func drawRecursion(obj: @Obj2d, pageX: int, pageY: int, hold: @Obj2d)
			do draw@rect((obj.x - 2 - pageX) $ float, (obj.y - 2 - pageY) $ float, (obj.width + 4) $ float, (obj.height + 4) $ float, hold =& obj ?(16#FF6666FF, 16#FF666666))
			do obj.draw(pageX, pageY)
			do obj.children.head()
			while(!obj.children.term())
				do drawRecursion(obj.children.get(), pageX, pageY, hold)
				do obj.children.next()
			end while
		end func
	end func

	+*func mouseDownL(x: int, y: int)
		var sel: int :: @listInfo.getSel()
		if(sel <= 0)
			do me.mode :: %move
			do me.hold :: selRecursion(me.obj2dRoot, x + me.pageX, y + me.pageY)
			if(me.hold =& null)
				do me.hold :: me.obj2dRoot
			end if
		else
			if (@lockingEditor)
				ret
			end if
			var name: []char :: @listInfo.getText(sel)
			do me.mode :: %put
			var obj: @Obj2d :: me.makeObj2d(name)
			do obj.init(me.getDefaultName(name), x, y, minSize, minSize)
			if(me.hold =& null)
				do me.obj2dRoot.children.add(obj)
			else
				do me.hold.children.add(obj)
			end if
			do me.hold :: obj
			do me.changed :: true
		end if
		do @drawEditor.paint()

		func selRecursion(obj: @Obj2d, x: int, y: int): @Obj2d
			do obj.children.head()
			while(!obj.children.term())
				var result: @Obj2d :: selRecursion(obj.children.get(), x, y)
				if(result <>& null)
					ret result
				end if
				do obj.children.next()
			end while
			if(obj.x <= x & x <= obj.x + obj.width & obj.y <= y & y <= obj.y + obj.height)
				ret obj
			end if
			ret null
		end func
	end func

	+*func mouseUpL(x: int, y: int)
		switch(me.mode)
		case %put
			if (@lockingEditor)
				ret
			end if
			do me.moveObj2d(x, y)
			do me.mode :: %none
			do @drawEditor.paint()
		end switch
	end func

	+*func mouseMove(x: int, y: int)
		switch(me.mode)
		case %put
			if (@lockingEditor)
				ret
			end if
			do me.moveObj2d(x, y)
			do @drawEditor.paint()
		end switch
	end func

	+*func focus(isFocus: bool)
		if(isFocus)
			do me.refreshScroll()
		end if
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		; TODO:
	end func

	+*func keyChar(key: char)
		; TODO:
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos
		do @drawEditor.paint()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos
		do @drawEditor.paint()
	end func

	+*func wheelX(wheel: int)
		; TODO:
	end func

	+*func wheelY(wheel: int)
		; TODO:
	end func

	+*func cmdUndo()
		; TODO:
	end func

	+*func cmdRedo()
		; TODO:
	end func

	+*func cmdCut()
		; TODO:
	end func

	+*func cmdCopy()
		; TODO:
	end func

	+*func cmdPaste()
		; TODO:
	end func

	+*func cmdDel()
		; TODO:
	end func

	+*func cmdSelAll()
		; TODO:
	end func

	const padding: int :: 32
	const minSize: int :: 50

	enum Mode
		none
		put
		move
	end enum

	var src: [][]char
	var obj2dRoot: @Obj2dRoot
	var pageX: int
	var pageY: int
	var mode: Mode
	var hold: @Obj2d

	*func undoImpl(undo2: @Undo)
		; TODO:
	end func

	func initFromMeta(src2: []char, ptr: &int)
	end func

	func getMeta(): []char
	end func

	func refreshScroll()
		var scrWidth: int
		var scrHeight: int
		do @drawEditor.getSize(&scrWidth, &scrHeight)
		do @scrollXSrc.setState(me.obj2dRoot.x, me.obj2dRoot.width + padding, scrWidth, me.pageX)
		do @scrollYSrc.setState(me.obj2dRoot.y, me.obj2dRoot.height + padding, scrHeight, me.pageY)
	end func

	func makeObj2d(name: []char): @Obj2d
	end func

	func getDefaultName(name: []char): []char
		var num: int :: 1
		var newName: []char
		while loop(true)
			do newName :: name ~ num.toStr()
			if(!searchRecursion(newName, me.obj2dRoot))
				break loop
			end if
			do num :+ 1
		end while
		ret newName

		func searchRecursion(name: []char, obj: @Obj2d): bool
			if(name = obj.name)
				ret true
			end if
			do obj.children.head()
			while(!obj.children.term())
				if(searchRecursion(name, obj.children.get()))
					ret true
				end if
				do obj.children.next()
			end while
			ret false
		end func
	end func

	func moveObj2d(x: int, y: int)
		var width: int :: x - me.hold.x
		var height: int :: y - me.hold.y
		if(width < minSize)
			do width :: minSize
		end if
		if(height < minSize)
			do height :: minSize
		end if
		do me.hold.width :: width
		do me.hold.height :: height
	end func
end class

class Obj2d()
	+func init(name: []char, x: int, y: int, width: int, height: int)
		do me.children :: #list<Obj2d>
		do me.name :: name
		do me.x :: x
		do me.y :: y
		do me.width :: width
		do me.height :: height
	end func

	+func draw(pageX: int, pageY: int)
	end func

	+func getSrc(): [][]char
	end func

	+func readMeta(src: []char, ptr: &int)
	end func

	+func writeMeta(): []char
	end func

	+var children: list<Obj2d>
	+var name: []char
	+var x: int
	+var y: int
	+var width: int
	+var height: int

	func readMetaBase(src: []char, ptr: &int)
		var x2: int
		do @arBaseParseWord(src, &ptr).toInt(&x2)
		var y2: int
		do @arBaseParseWord(src, &ptr).toInt(&y2)
		var width2: int
		do @arBaseParseWord(src, &ptr).toInt(&width2)
		var height2: int
		do @arBaseParseWord(src, &ptr).toInt(&height2)
		do me.init(@arBaseParseWord(src, &ptr), x2, y2, width2, height2)
	end func

	func writeMetaBase(type: []char): []char
		ret ",\{type},\{me.name},\{me.x.toStr()},\{me.y.toStr()},\{me.width.toStr()},\{me.height.toStr()},\{(^me.children).toStr()}"
	end func
end class

class Obj2dRoot(@Obj2d)
	+*func draw(pageX: int, pageY: int)
		do draw@rect((me.x - pageX) $ float, (me.y - pageY) $ float, me.width $ float, me.height $ float, me.color)
	end func

	+*func getSrc(): [][]char
		ret [""]
	end func

	+*func writeMeta(): []char
		ret (^me.children).toStr()
	end func

	+var color: int
end class

class DocumentArWnd(@DocumentArBase)
	*func initFromMeta(src2: []char, ptr: &int)
		do me.obj2dRoot.color :: draw@white
		do me.initFromMetaRecursion(me.obj2dRoot, src2, &ptr)
	end func

	*func getMeta(): []char
		ret "wnd"
	end func

	*func makeObj2d(name: []char): @Obj2d
		switch(name)
		case "Button"
			ret #Obj2dBtn
		end switch
		assert(false)
	end func

	class Obj2dBtn(@Obj2d)
		+*func draw(pageX: int, pageY: int)
			do draw@rect((me.x - pageX) $ float, (me.y - pageY) $ float, me.width $ float, me.height $ float, 16#FF808080)
		end func

		+*func getSrc(): [][]char
			ret [""]
			; TODO:
		end func

		+*func readMeta(src: []char, ptr: &int)
			do me.readMetaBase(src, &ptr)
		end func

		+*func writeMeta(): []char
			ret me.writeMetaBase("btn")
		end func
	end class

	func initFromMetaRecursion(parent: @Obj2d, src: []char, ptr: &int)
		var num: int
		do @arBaseParseWord(src, &ptr).toInt(&num)
		for i(0, num - 1)
			var obj: @Obj2d
			switch(@arBaseParseWord(src, &ptr))
			case "btn"
				do obj :: #Obj2dBtn
			default
				ret
			end switch
			do obj.readMeta(src, &ptr)
			do parent.children.add(obj)
			do me.initFromMetaRecursion(obj, src, &ptr)
		end for
	end func
end class

class DocumentArDraw(@DocumentArDraw)
	*func initFromMeta(src2: []char, ptr: &int)
		do me.obj2dRoot.color :: draw@white
		; TODO:
	end func

	*func getMeta(): []char
		ret "draw"
	end func

	*func makeObj2d(name: []char): @Obj2d
	end func
end class

const fontSize: int :: 11
const cellWidth: int :: 9
const cellHeight: int :: 18
const title: []char :: "Kuin Programming Language"
const langEn: bool :: false
const colorBack: int :: 16#FFFFF5F5
const untitledSrcName: []char :: "_untitled_.kn"
const untitledInternalName: []char :: "\\_untitled_"

enum CharColor
	none
	identifier
	global
	reserved
	number
	str
	char_
	lineComment
	comment
	symbol
	max
end enum

var mainSrcName: []char
var mainSrcDir: []char
var sysDir: []char
var srcCharColor: []int
var font: draw@Font
var documents: dict<[]char, @Document>
var curDocument: @Document
var drag: bool
var dirtyInterpret: int
var dirtyInterpretTime: int
var dirtyHint: bool
var dirtyHintTime : int
var listInfoItem: list<@ListInfoItem>
var auxiliaryErr: dict<@Pos, []char>
var lockingEditor: bool
var textErr: []char
var textHint: []char
var textFunc: []char
var textLog: []char

func main()
	do @initCompiler()
	do wnd@onKeyPress(@onKeyPress)
	do makeWnd()
	do initEditor()

	if(^lib@cmdLine() > 0)
		do @open(lib@cmdLine()[0].replace("\\", "/"))
	else
		do @new(null, null)
	end if

	do mainLoop()

	func makeWnd()
		do @wndMain :: wnd@makeWnd(null, %normal, 1224, 768, @title)
		do @wndMain.minMax(930, 640, -1, -1)
		do @wndMain.onClose :: @wndMainOnClose
		do @wndMain.onActivate :: @wndMainOnActivate
		do @wndMain.onPushMenu :: @wndMainOnPushMenu
		do @treeItem :: wnd@makeTree(@wndMain, 12, 12, 244, 466, %fix, %fix)
		do @listInfo :: wnd@makeList(@wndMain, 12, 484, 244, 272, %fix, %scale)
		do @listInfo.onSel :: @listInfoOnSel
		do @editFile :: wnd@makeEdit(@wndMain, 262, 12, 759, 15, %scale, %fix)
		do @editFile.readonly(true)
		do @drawEditor :: wnd@makeDraw(@wndMain, 262, 33, 759, 582, %scale, %scale, true)
		do @drawEditor.onPaint :: @drawEditorOnPaint
		do @drawEditor.onMouseDownL :: @drawEditorOnMouseDownL
		do @drawEditor.onMouseUpL :: @drawEditorOnMouseUpL
		do @drawEditor.onMouseMove :: @drawEditorOnMouseMove
		do @drawEditor.onFocus :: @drawEditorOnFocus
		do @drawEditor.onKeyDown :: @drawEditorOnKeyDown
		do @drawEditor.onKeyChar :: @drawEditorOnKeyChar
		do @drawEditor.onScrollX :: @drawEditorOnScrollX
		do @drawEditor.onScrollY :: @drawEditorOnScrollY
		do @drawEditor.onMouseWheelX :: @drawEditorOnMouseWheelX
		do @drawEditor.onMouseWheelY :: @drawEditorOnMouseWheelY
		do @scrollXSrc :: wnd@makeScrollX(@drawEditor, 0, 565, 742, 17, %scale, %move)
		do @scrollXSrc.setState(0, 0, 1, 0)
		do @scrollYSrc :: wnd@makeScrollY(@drawEditor, 742, 0, 17, 565, %move, %scale)
		do @scrollYSrc.setState(0, 0, 1, 0)
		do @editHint :: wnd@makeEditMulti(@wndMain, 262, 621, 391, 135, %scale, %move)
		do @editHint.readonly(true)
		do @editLog :: wnd@makeEditMulti(@wndMain, 659, 621, 553, 135, %move, %move)
		do @editLog.readonly(true)
		do @btnCompile :: wnd@makeBtn(@wndMain, 1027, 12, 185, 23, %move, %fix, @langEn ?("Compile && Run", "コンパイル＆実行"))
		do @btnCompile.onPush :: @btnCompileOnPush
		do @groupEnv :: wnd@makeGroup(@wndMain, 1027, 41, 185, 62, %move, %fix, @langEn ?("Environment", "実行環境"))
		do @radioEnvWnd :: wnd@makeRadio(@groupEnv, 6, 18, 173, 16, %fix, %fix, @langEn ?("Window", "ウインドウ"))
		do @radioEnvWnd.setChk(true)
		do @radioEnvCui :: wnd@makeRadio(@groupEnv, 6, 40, 173, 16, %fix, %fix, @langEn ?("CUI", "CUI"))
		do @btnRls :: wnd@makeBtn(@wndMain, 1027, 109, 185, 23, %move, %fix, @langEn ?("Release Build...", "リリースビルド"))
		do @btnRls.onPush :: @btnRlsOnPush
		do @listFile :: wnd@makeList(@wndMain, 1027, 255, 185, 360, %move, %scale)
		do @listFile.onSel :: @listFileOnSel
		do @menuMain :: wnd@makeMenu()
		do @popupMainFile :: wnd@makePopup()
		do @popupMainFile.add(16#0001, @langEn ?("&New\tCtrl+N", "新規作成(&N)\tCtrl+N"))
		do @popupMainFile.add(16#0002, @langEn ?("&Load...\tCtrl+O", "開く(&O)\tCtrl+O"))
		do @popupMainFile.addLine()
		do @popupMainFile.add(16#0003, @langEn ?("&Save All\tCtrl+S", "すべて保存(&S)\tCtrl+S"))
		do @popupMainFile.add(16#0004, @langEn ?("Save &As...\tCtrl+Shift+S", "名前を付けて保存(&A)\tCtrl+Shift+S"))
		do @popupMainFile.addLine()
		do @popupMainFile.add(16#0005, @langEn ?("E&xit\tCtrl+Q", "終了(&E)\tCtrl+Q"))
		do @menuMain.addPopup(@langEn ?("&File", "ファイル(&F)"), @popupMainFile)
		do @popupMainEdit :: wnd@makePopup()
		do @popupMainEdit.add(16#0030, @langEn ?("Add Ne&w File\tCtrl+Shift+A", "新しいファイルを追加(&W)\tCtrl+Shift+A"))
		do @popupMainEdit.add(16#0031, @langEn ?("Add Existin&g File", "既存のファイルを追加(&G)"))
		do @popupMainEdit.addLine()
		do @popupMainEdit.add(16#0032, @langEn ?("&Undo\tCtrl+Z", "元に戻す(&U)\tCtrl+Z"))
		do @popupMainEdit.add(16#0033, @langEn ?("&Redo\tCtrl+Y", "やり直し(&R)\tCtrl+Y"))
		do @popupMainEdit.addLine()
		do @popupMainEdit.add(16#0034, @langEn ?("Cu&t\tCtrl+X", "切り取り(&T)\tCtrl+X"))
		do @popupMainEdit.add(16#0035, @langEn ?("&Copy\tCtrl+C", "コピー(&C)\tCtrl+C"))
		do @popupMainEdit.add(16#0036, @langEn ?("&Paste\tCtrl+V", "貼り付け(&P)\tCtrl+V"))
		do @popupMainEdit.add(16#0037, @langEn ?("&Delete\tDel", "削除(&D)\tDel"))
		do @popupMainEdit.add(16#0038, @langEn ?("Select &All\tCtrl+A", "すべて選択(&A)\tCtrl+A"))
		do @menuMain.addPopup(@langEn ?("&Edit", "編集(&E)"), @popupMainEdit)
		do @popupMainBuild :: wnd@makePopup()
		do @popupMainBuild.add(16#0020, @langEn ?("&Compile && Run\tF5", "コンパイル＆実行(&C)\tF5"))
		do @popupMainBuild.addLine()
		do @popupMainBuild.add(16#0021, @langEn ?("&Release Build...\tCtrl+Shift+B", "リリースビルド(&R)\tCtrl+Shift+B"))
		do @menuMain.addPopup(@langEn ?("&Build", "ビルド(&B)"), @popupMainBuild)
		do @popupMainHelp :: wnd@makePopup()
		do @popupMainHelp.add(16#0010, @langEn ?("&View Help\tF1", "ヘルプの表示(&V)\tF1"))
		do @popupMainHelp.addLine()
		do @popupMainHelp.add(16#0011, @langEn ?("&About Kuin...", "Kuinについて(&A)..."))
		do @menuMain.addPopup(@langEn ?("&Help", "ヘルプ(&H)"), @popupMainHelp)
		do @wndMain.setMenu(@menuMain)
	end func

	func initEditor()
		do @sysDir :: file@exeDir() ~ "sys/"
		do @srcCharColor :: #[%max $ @CharColor $ int]int
		do @srcCharColor[%none $ @CharColor $ int] :: 16#FF999999
		do @srcCharColor[%identifier $ @CharColor $ int] :: 16#FF009BEA
		do @srcCharColor[%global $ @CharColor $ int] :: 16#FFCC00F6
		do @srcCharColor[%reserved $ @CharColor $ int] :: 16#FF1400F6
		do @srcCharColor[%number $ @CharColor $ int] :: 16#FFEA0062
		do @srcCharColor[%str $ @CharColor $ int] :: 16#FFEA0062
		do @srcCharColor[%char_ $ @CharColor $ int] :: 16#FFEA0062
		do @srcCharColor[%lineComment $ @CharColor $ int] :: 16#FF1EB000
		do @srcCharColor[%comment $ @CharColor $ int] :: 16#FF1EB000
		do @srcCharColor[%symbol $ @CharColor $ int] :: 16#FF666666
		do @font :: draw@makeFont("Consolas", @fontSize, false, false, false, @cellWidth $ float)
		do @drag :: false
		do @lockingEditor :: false
		do @textErr :: ""
		do @textHint :: ""
		do @textFunc :: ""
		do @textLog :: ""
	end func

	func mainLoop()
		while(wnd@act())
			if(@curDocument =$ @DocumentSrc)
				var document: @DocumentSrc :: @curDocument $ @DocumentSrc
				switch(@dirtyInterpret)
				case 0
					if(lib@sysTime() - @dirtyInterpretTime > 150)
						do @interpret1(document.src.src, document.src.color)
						do document.interpreted :: true
						do @drawEditor.paint()
						do @dirtyInterpret :: 1
					end if
				case 1
					if(lib@sysTime() - @dirtyInterpretTime > 1200)
						do @resetMemAllocator()
						do @resetAuxiliary()
						try
							do @interpret2(@mainSrcName, @getSrc, null, @getEnv(), @logForInterpret, @langEn ?(1, 0))
						catch
						end try
						do @updateAuxiliary()
						do @updateUi()
						do @dirtyInterpret :: 2
					end if
				end switch
				if(@dirtyHint)
					if(lib@sysTime() - @dirtyHintTime > 100 & @dirtyInterpret >= 1)
						do document.showHint()
						do @dirtyHint :: false
					end if
				end if
			end if
		end while

		do @finCompiler()
	end func
end func

func onKeyPress(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl): bool
	switch(shiftCtrl)
	case %none
		switch(key)
		case %del
			do @wndMainOnPushMenu(@wndMain, 16#0037)
			ret true
		case %f1
			do @wndMainOnPushMenu(@wndMain, 16#0011)
			ret true
		case %f5
			do @wndMainOnPushMenu(@wndMain, 16#0020)
			ret true
		end switch
	case %shift
		switch(key)
		end switch
	case %ctrl
		switch(key)
		case %a
			do @wndMainOnPushMenu(@wndMain, 16#0038)
			ret true
		case %c
			do @wndMainOnPushMenu(@wndMain, 16#0035)
			ret true
		case %n
			do @wndMainOnPushMenu(@wndMain, 16#0001)
			ret true
		case %o
			do @wndMainOnPushMenu(@wndMain, 16#0002)
			ret true
		case %s
			do @wndMainOnPushMenu(@wndMain, 16#0003)
			ret true
		case %q
			do @wndMainOnPushMenu(@wndMain, 16#0005)
			ret true
		case %v
			do @wndMainOnPushMenu(@wndMain, 16#0036)
			ret true
		case %x
			do @wndMainOnPushMenu(@wndMain, 16#0034)
			ret true
		case %z
			do @wndMainOnPushMenu(@wndMain, 16#0032)
			ret true
		end switch
	case (%shift $ wnd@ShiftCtrl).or(%ctrl)
		switch(key)
		case %a
			do @wndMainOnPushMenu(@wndMain, 16#0030)
		case %b
			do @wndMainOnPushMenu(@wndMain, 16#0021)
			ret true
		case %s
			do @wndMainOnPushMenu(@wndMain, 16#0004)
			ret true
		case %z
			do @wndMainOnPushMenu(@wndMain, 16#0033)
			ret true
		end switch
	end switch
	ret false
end func

func open(file: []char)
	var src: list<[]char> :: #list<[]char>
	var filePtr: file@Reader :: file@makeReader(file)
	if(filePtr =& null)
		var msg: []char
		if(@langEn)
			do msg :: "Loading failed. " ~ file
		else
			do msg :: "読み込みに失敗しました。 " ~ file
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret
	end if
	while(!filePtr.term())
		do src.add(filePtr.readLine())
	end while
	do filePtr.fin()
	do @new(file, src.toArray())
end func

func new(srcName: []char, src: [][]char)
	do @documents :: #dict<[]char, @Document>
	do @curDocument :: #@DocumentSrc
	do @curDocument.init(src)
	do @mainSrcName :: srcName =& null ?(@untitledSrcName, srcName)
	do @mainSrcDir :: srcName =& null ?("", file@dir(srcName))
	do @documents.add(@mainSrcName, @curDocument)
	do @setDirtyInterpret()
	do @setDirtyHint()
	do @resetAuxiliary()
	do @updateUi()
	do @drawEditor.paint()
	do @drawEditor.focus()
	; TODO:
end func

func save(): bool
	var file: []char :: wnd@saveFileDialog(@wndMain, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0, "kn")
	if(file =& null)
		ret false
	end if
	if(!@saveSrc(file, @curDocument.getSrc()))
		ret false
	end if
	do @mainSrcName :: file
	do @mainSrcDir :: file@dir(file)
	var newDocuments: dict<[]char, @Document> :: #dict<[]char, @Document>
	var data: @DocumentsClass :: #@DocumentsClass
	do data.documents :: newDocuments
	do @documents.forEach(callback, data)
	do newDocuments.add(file, @curDocument)
	do @documents :: newDocuments
	do @curDocument.changed :: false
	do @updateUi()
	ret true

	func callback(src: []char, document: @Document, data: @DocumentsClass): bool
		if(document <>& @curDocument)
			do data.documents.add(src, document)
		end if
		ret true
	end func
end func

func saveAll(): bool
	if(@mainSrcName = @untitledSrcName)
		if(!@save())
			ret false
		end if
	end if
	do @saveAllSuccess :: true
	do @documents.forEach(callback, null)
	do @updateUi()
	ret @saveAllSuccess

	func callback(src: []char, document: @Document, data: kuin@Class): bool
		if(document.changed)
			if(@saveSrc(src, document.getSrc()))
				do document.changed :: false
			else
				do @saveAllSuccess :: false
			end if
		end if
		ret true
	end func
end func
var saveAllSuccess: bool

func saveSrc(path: []char, src: [][]char): bool
	var filePtr: file@Writer :: file@makeWriter(path, false)
	if(filePtr =& null)
		var msg: []char
		if(@langEn)
			do msg :: "Saving failed. " ~ path
		else
			do msg :: "保存に失敗しました。 " ~ path
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret false
	end if
	for line(0, ^src - 1)
		do filePtr.writeStr(src[line])
		if(line <> ^src - 1 | src[line] <> "")
			do filePtr.writeChar('\n')
		end if
	end for
	do filePtr.fin()
	ret true
end func

func add(file: []char): @Document
	if(!(^@sysDir <= ^file & @sysDir = file.sub(0, ^@sysDir) | @mainSrcDir <> "" & ^@mainSrcDir <= ^file & @mainSrcDir = file.sub(0, ^@mainSrcDir)))
		ret null
	end if

	var src: list<[]char> :: #list<[]char>
	var filePtr: file@Reader :: file@makeReader(file)
	if(filePtr =& null)
		ret null
	end if

	var document: @Document :: null
	var first: bool :: true
	while loop(!filePtr.term())
		var line: []char :: filePtr.readLine()
		do src.add(line)
		if(first)
			do first :: false
			if(^line >= 3 & line.sub(0, 3) = ";;[")
				var ptr: int :: 6
				while(ptr < ^line & line[ptr] <> ']')
					do ptr :+ 1
				end while
				switch(line.sub(3, ptr - 3))
				case "ar_wnd"
					do document :: #@DocumentArWnd
				end switch
				break loop
			end if
		end if
	end while
	do filePtr.fin()
	if(document =& null)
		do document :: #@DocumentSrc
	end if
	do document.init(src.toArray())
	do @documents.add(file, document)
	ret document
end func

func setCurSrc(document: @Document)
	do @curDocument :: document
	if(document =$ @DocumentSrc)
		var document2: @DocumentSrc :: document $ @DocumentSrc
		if(!document2.interpreted)
			do @interpret1(document2.src.src, document2.src.color)
			do document2.interpreted :: true
		end if
	end if
	do @drawEditor.paint()
	do @drawEditor.focus()
end func

func chkChanged(): bool
	do @chkCloseChanged :: false
	do @documents.forEach(callback, null)
	if(!@chkCloseChanged)
		ret true
	end if
	var msg: []char
	if(@langEn)
		do msg :: "Do you want to save changes to the documents?"
	else
		do msg :: "ドキュメントへの変更を保存しますか？"
	end if
	var result: wnd@MsgBoxResult :: wnd@msgBox(@wndMain, msg, @title, %warn, %yesNoCancel)
	if(result = %cancel)
		ret false
	elif(result = %no)
		ret true
	end if
	ret @saveAll()

	func callback(src: []char, document: @Document, data: kuin@Class): bool
		if(document.changed)
			do @chkCloseChanged :: true
			ret false
		end if
		ret true
	end func
end func
var chkCloseChanged: bool

func wndMainOnClose(wnd: wnd@WndBase): bool
	if(@lockingEditor)
		do wnd@msgBox(@wndMain, @langEn ?("It is running.", "実行中です。"), @title, %err, %ok)
		ret false
	end if
	if(@chkChanged())
		var dir: []char :: file@sysDir(%appData) ~ "Kuin/"
		try
			do file@delDir(dir)
		catch
		end try
		ret true
	end if
	ret false
end func

func wndMainOnActivate(wnd: wnd@WndBase, active: bool, minimized: bool)
	if(active & !minimized)
		do @drawEditor.focus()
	end if
end func

func wndMainOnPushMenu(wnd: wnd@WndBase, id: int)
	switch(id)
	case 16#0001
		if(@lockingEditor)
			ret
		end if
		if (@chkChanged())
			do @new(null, null)
		end if
	case 16#0002
		if(@lockingEditor)
			ret
		end if
		if (@chkChanged())
			var file: []char :: wnd@openFileDialog(@wndMain, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0)
			if(file <>& null)
				do @open(file)
			end if
		end if
	case 16#0003
		if(@lockingEditor)
			ret
		end if
		do @saveAll()
	case 16#0004
		if(@lockingEditor)
			ret
		end if
		do @save()
	case 16#0005
		do @wndMain.close()
	case 16#0010
		do wnd@msgBox(@wndMain, "Good luck!", @title, %info, %ok)
	case 16#0011
		block
			var major: int
			var minor: int
			var micro: int
			do @version(&major, &minor, &micro)
			do wnd@msgBox(@wndMain, "Kuin Programming Language\nVersion \{major}.\{minor}.\{micro}\n(C)Kuina-chan", @title, %info, %ok)
		end block
	case 16#0020
		if(@lockingEditor)
			ret
		end if
		do @btnCompileOnPush(@btnCompile)
	case 16#0021
		if(@lockingEditor)
			ret
		end if
		do @btnRlsOnPush(@btnRls)
	case 16#0030
		if(@lockingEditor)
			ret
		end if
		do @addNewFile()
	case 16#0031
		if(@lockingEditor)
			ret
		end if
		do @addExistingFile()
	case 16#0032
		do @curDocument.cmdUndo()
	case 16#0033
		do @curDocument.cmdRedo()
	case 16#0034
		do @curDocument.cmdCut()
	case 16#0035
		do @curDocument.cmdCopy()
	case 16#0036
		do @curDocument.cmdPaste()
	case 16#0037
		do @curDocument.cmdDel()
	case 16#0038
		do @curDocument.cmdSelAll()
	end switch
end func

func listInfoOnSel(wnd: wnd@WndBase)
	if(@curDocument =$ @DocumentSrc)
		var sel: int :: @listInfo.getSel()
		if(sel <> -1 & sel < ^@listInfoItem)
			do @listInfoItem.head()
			var item: @ListInfoItem :: @listInfoItem.getOffset(sel)
			if(item.pos.src = @srcNameToInternalName(@mainSrcName))
				do (@curDocument $ @DocumentSrc).move(item.pos.col - 1, item.pos.row - 1)
				do @drawEditor.paint()
				do @drawEditor.focus()
			end if
			do @textErr :: item.text
			do @updateLog()
			do @dirtyHint :: false
		end if
	elif(@curDocument =$ @DocumentArBase)
	end if
end func

func drawEditorOnPaint(wnd: wnd@WndBase, width: int, height: int)
	do @curDocument.draw(width, height)
	do draw@render(0)
end func

func drawEditorOnMouseDownL(wnd: wnd@WndBase, x: int, y: int)
	do @drag :: true
	do @curDocument.mouseDownL(x, y)
end func

func drawEditorOnMouseUpL(wnd: wnd@WndBase, x: int, y: int)
	do @drag :: false
	do @curDocument.mouseUpL(x, y)
end func

func drawEditorOnMouseMove(wnd: wnd@WndBase, x: int, y: int)
	do @curDocument.mouseMove(x, y)
end func

func drawEditorOnFocus(wnd: wnd@WndBase, focus: bool)
	do @curDocument.focus(focus)
end func

func drawEditorOnKeyDown(wnd: wnd@WndBase, key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	do @curDocument.keyDown(key, shiftCtrl)
end func

func drawEditorOnKeyChar(wnd: wnd@WndBase, key: char)
	do @curDocument.keyChar(key)
end func

func drawEditorOnScrollX(wnd: wnd@WndBase, pos: int)
	do @curDocument.scrollX(pos)
end func

func drawEditorOnScrollY(wnd: wnd@WndBase, pos: int)
	do @curDocument.scrollY(pos)
end func

func drawEditorOnMouseWheelX(wnd: wnd@WndBase, wheel: int)
	do @curDocument.wheelX(wheel)
end func

func drawEditorOnMouseWheelY(wnd: wnd@WndBase, wheel: int)
	do @curDocument.wheelY(wheel)
end func

func btnCompileOnPush(wnd: wnd@WndBase)
	if(@lockingEditor)
		ret
	end if
	do @lockEditor(true)
	var tmp: []char :: file@sysDir(%appData) ~ "Kuin/tmp/"
	var out: []char :: tmp ~ "out.exe"
	try
		do file@makeDir(tmp)
	catch
		var msg: []char
		if(@langEn)
			do msg :: "Could not delete. " ~ tmp
		else
			do msg :: "削除できませんでした。 " ~ tmp
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret
	end try
	do @resetMemAllocator()
	do @textLog :: ""
	do @updateLog()
	var cmd: []char
	var cmdLine: []char
	if(@radioEnvWnd.getChk())
		do cmd :: out
		do cmdLine :: null
	elif(@radioEnvCui.getChk())
		do cmd :: file@sysDir(%system32) ~ "cmd.exe"
		do cmdLine :: "/C \"\"" ~ file@exeDir().replace("/", "\\") ~ "sys\\launcher.bat\" \"" ~ out.replace("/", "\\") ~ "\"\""
	end if
	try
		do @resetAuxiliary()
		if(@build(@mainSrcName, @getSrc, null, out, null, false, @getEnv(), @log, @langEn ?(1, 0)))
			if (@mainSrcName <> @untitledSrcName)
				var filePtr: file@Writer :: file@makeWriter(tmp ~ "_curdir_.txt", false)
				do filePtr.writeStr(file@dir(@mainSrcName))
				do filePtr.writeChar('\n')
				do filePtr.fin()
			end if
			do @textLog :~ "IK9999: 実行。\n"
			do @updateLog()
			if(@runDbg(cmd, cmdLine, idleFunc, eventFunc))
				do @textLog :~ "IK9999: 正常終了。\n"
				do @updateLog()
			else
				do @textLog :~ "IK9999: 実行失敗。\n"
				do @updateLog()
				do wnd@msgBox(@wndMain, @langEn ?("Could not run.", "実行できませんでした。"), @title, %err, %ok)
			end if
		end if
		do @updateAuxiliary()
	catch
		do wnd@msgBox(@wndMain, @langEn ?("Unexpected error.", "予期せぬエラーです。"), @title, %err, %ok)
	end try
	do @updateUi()
	do @lockEditor(false)

	func idleFunc()
		do wnd@act()
	end func

	func eventFunc(type: int, str: []char): int
		switch(type)
		case 0
			do @textLog :~ str.sub(5, -1) ~ "\n"
			do @updateLog()
		end switch
	end func
end func

func btnRlsOnPush(wnd: wnd@WndBase)
	if(@lockingEditor)
		ret
	end if
	var file: []char :: wnd@saveFileDialog(@wndMain, [@langEn ?("Archive file (*.zip)", "アーカイブファイル (*.zip)"), "*.zip"], 0, "zip")
	if(file =& null)
		ret
	end if
	do @lockEditor(true)
	var fileName: []char :: file@delExt(file@fileName(file))
	var tmp: []char :: file@sysDir(%appData) ~ "Kuin/rls/" ~ fileName ~ "/"
	var out: []char :: tmp ~ fileName ~ ".exe"
	try
		do file@makeDir(tmp)
	catch
		var msg: []char
		if(@langEn)
			do msg :: "Could not delete. " ~ tmp
		else
			do msg :: "削除できませんでした。 " ~ tmp
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret
	end try
	do @resetMemAllocator()
	do @textLog :: ""
	do @updateLog()
	try
		do @resetAuxiliary()
		if(@build(@mainSrcName, @getSrc, null, out, null, true, @getEnv(), @log, @langEn ?(1, 0)))
			if(@mainSrcName <> @untitledSrcName)
				var resSrc: []char :: file@dir(@mainSrcName) ~ "res/"
				if(file@exist(resSrc))
					var resDst: []char :: tmp ~ "res/"
					do file@copyDir(resDst, resSrc)
				end if
			end if
			if(!zip@zip(file, tmp, -1))
				var msg: []char
				if(@langEn)
					do msg :: "Could not make the archive file. " ~ file
				else
					do msg :: "アーカイブファイルを作成できませんでした。 " ~ file
				end if
				do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
				ret
			end if
			do wnd@msgBox(@wndMain, @langEn ?("The build succeeded.", "ビルドが成功しました。"), @title, %info, %ok)
		end if
		do @updateAuxiliary()
	catch
		do wnd@msgBox(@wndMain, @langEn ?("Unexpected error.", "予期せぬエラーです。"), @title, %err, %ok)
	end try
	do @updateUi()
	do @lockEditor(false)
end func

func listFileOnSel(wnd: wnd@WndBase)
	var sel: int :: @listFile.getSel()
	if(sel <> -1)
		var src: []char :: @internalNameToSrcName(removePrefix(@listFile.getText(sel)))
		var document: @Document :: @documents.get(src)
		if(document <>& null)
			do @setCurSrc(document)
		end if
	end if
	do @updateUi()

	func removePrefix(src: []char): []char
		var begin: int :: 0
		while loop(begin < ^src)
			switch(src[begin])
			case '*', '>'
				do begin :+ 1
			default
				break loop
			end switch
		end while
		if(begin = 0)
			ret src
		else
			ret src.sub(begin, -1)
		end if
	end func
end func

func getSrc(path: []char): [][]char
	var path2: []char :: (##path).replace("\\", "/")
	var document: @Document :: @documents.get(path2)
	if(document <>& null)
		ret document.getSrc()
	end if

	do document :: @add(path2)
	ret document =& null ?(null, document.getSrc())
end func

func getEnv(): []char
	if(@radioEnvWnd.getChk())
		ret "wnd"
	elif(@radioEnvCui.getChk())
		ret "cui"
	end if
	ret "wnd"
end func

func log(args: [][]char, row: int, col: int)
	var msg: []char :: @nullStr(args[0]) ~ ": " ~ @nullStr(args[1])
	if(args[2] =& null)
		do @textLog :~ msg ~ "\n"
	else
		do @textLog :~ msg ~ " (" ~ @nullStr(args[2]) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ ")\n"
	end if
	do @updateLog()
	var pos: @Pos :: #@Pos
	do pos.src :: args[2] =& null ?("", ##args[2])
	do pos.row :: row
	do pos.col :: col
	if(!@auxiliaryErr.exist(pos))
		do @auxiliaryErr.add(pos, @errStr(args[0], args[1], args[2], row, col))
	end if
end func

func errStr(code: []char, msg: []char, src: []char, row: int, col: int): []char
	ret "[" ~ @nullStr(src) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ "] " ~ @nullStr(code) ~ ": " ~ @nullStr(msg)
end func

func nullStr(s: []char): []char
	ret s =& null ?("(null)", s)
end func

func setDirtyInterpret()
	do @dirtyInterpret :: 0
	do @dirtyInterpretTime :: lib@sysTime()
end func

func setDirtyHint()
	do @dirtyHint :: true
	do @dirtyHintTime :: lib@sysTime()
end func

func resetAuxiliary()
	do @auxiliaryErr :: #dict<@Pos, []char>
	do @listInfoItem :: #list<@ListInfoItem>
end func

func updateAuxiliary()
	do @auxiliaryErr.forEach(callback, null)
	do @drawEditor.paint()

	func callback(pos: @Pos, msg: []char, data: kuin@Class): bool
		var listInfoItem: @ListInfoItem :: #@ListInfoItem
		do listInfoItem.text :: msg
		do listInfoItem.pos :: pos
		do @listInfoItem.add(listInfoItem)

		; Fill in words with the error color.
		var srcName: []char :: @internalNameToSrcName(pos.src)
		if(srcName =& null)
			ret true
		end if
		var document: @Document :: @documents.get(srcName)
		if(document <>& null & document =$ @DocumentSrc)
			var document2: @DocumentSrc :: document $ @DocumentSrc
			var x: int :: pos.col - 1
			var y: int :: pos.row - 1
			var color: bit8
			if(moveWordTop(document2.src.src, document2.src.color, &x, &y, &color))
				while(x < ^document2.src.color[y] & document2.src.color[y][x].and(16#7Fb8) = color)
					do document2.src.color[y][x] :: document2.src.color[y][x].or(16#80b8)
					do x :+ 1
				end while
			end if
		end if
		ret true

		func moveWordTop(src: [][]char, srcColor: [][]bit8, x: &int, y: &int, color: &bit8): bool
			if(y < 0)
				do y :: 0
			elif(^srcColor <= y)
				do y :: ^srcColor - 1
			end if
			if(1 <= x & x < ^srcColor[y] & (src[y][x] = ' ' | src[y][x] = '\t' | srcColor[y][x].and(16#7Fb8) = %comment $ @CharColor $ bit8 | srcColor[y][x].and(16#7Fb8) = %symbol $ @CharColor $ bit8))
				do x :- 1
			end if
			if(x < 0)
				do x :: 0
			elif(^srcColor[y] <= x)
				do x :: ^srcColor[y] - 1
			end if
			if(^srcColor[y] <> 0)
				do color :: srcColor[y][x].and(16#7Fb8)
				while(x >= 1 & srcColor[y][x - 1].and(16#7Fb8) = color)
					do x :- 1
				end while
				ret true
			end if
			ret false
		end func
	end func
end func

func srcNameToInternalName(srcName: []char): []char
	if(^@sysDir <= ^srcName & @sysDir = srcName.sub(0, ^@sysDir))
		ret file@delExt(srcName.sub(^@sysDir, -1)).replace("/", "\\")
	elif(@mainSrcDir <> "" & ^@mainSrcDir <= ^srcName & @mainSrcDir = srcName.sub(0, ^@mainSrcDir))
		ret "\\" ~ file@delExt(srcName.sub(^@mainSrcDir, -1)).replace("/", "\\")
	else
		ret "\\" ~ file@delExt(file@fileName(srcName)).replace("/", "\\")
	end if
end func

func internalNameToSrcName(internalName: []char): []char
	if(internalName = @untitledInternalName)
		ret @untitledSrcName
	end if
	if(^internalName > 1 & internalName[0] = '\\')
		ret @mainSrcDir ~ internalName.sub(1, -1).replace("\\", "/") ~ ".kn"
	end if
	ret @sysDir ~ internalName.replace("\\", "/") ~ ".kn"
end func

func logForInterpret(args: [][]char, row: int, col: int)
	var pos: @Pos :: #@Pos
	do pos.src :: args[2] =& null ?("", ##args[2])
	do pos.row :: row
	do pos.col :: col
	if(!@auxiliaryErr.exist(pos))
		do @auxiliaryErr.add(pos, @errStr(args[0], args[1], args[2], row, col))
	end if
end func

func updateUi()
	do @editFile.setText("")
	do @listInfo.clear()
	if(@curDocument =$ @DocumentSrc)
		; TODO: do @listInfoItem.sort()
		do @listInfoItem.head()
		while(!@listInfoItem.term())
			do @listInfo.add(@listInfoItem.get().text)
			do @listInfoItem.next()
		end while
	elif(@curDocument =$ @DocumentArWnd)
		do @listInfo.add(@langEn ?("None", "なし"))
		do @listInfo.add("Button")
	end if

	do @listFile.clear()
	do @documents.forEach(callback, null)

	func callback(src: []char, document: @Document, data: kuin@Class): bool
		var prefix: []char :: ""
		var internalName: []char :: @srcNameToInternalName(src)
		if(document =& @curDocument)
			do prefix :~ ">"
			do @editFile.setText(internalName)
		end if
		if(document.changed)
			do prefix :~ "*"
		end if
		do @listFile.add(prefix ~ internalName)
		ret true
	end func
end func

func addNewFile()
	if(@mainSrcDir = "")
		do wnd@msgBox(@wndMain, @langEn ?("The main source file must be saved before adding another file.", "ファイルを追加する前にメインソースファイルを保存しなければなりません。"), @title, %err, %ok)
		ret
	end if
	do @wndDlg :: wnd@makeWnd(@wndMain, %fix, 640, 480, @langEn?("Add New File", "新しいファイルを追加"))
	do @wndDlgResultFile :: null
	do @wndDlgResultType :: 0
	do @wndDlgListType :: wnd@makeList(@wndDlg, 12, 12, 616, 100, %fix, %scale)
	do @wndDlgListType.add(@langEn?("Source Code", "ソースコード"))
	; TODO: do @wndDlgListType.add(@langEn?("Window", "ウインドウ"))
	do @wndDlgListType.setSel(0)
	do @wndDlgEditFile :: wnd@makeEdit(@wndDlg, 12, 118, 510, 19, %fix, %fix)
	var btnFile: wnd@Btn :: wnd@makeBtn(@wndDlg, 528, 118, 100, 23, %fix, %fix, @langEn ?("Browse...", "参照..."))
	do btnFile.onPush :: btnFileOnPush
	var btnAdd: wnd@Btn :: wnd@makeBtn(@wndDlg, 12, 143, 100, 23, %fix, %fix, @langEn ?("Add", "追加"))
	do btnAdd.onPush :: btnAddOnPush
	do @wndDlg.modal()
	if(@wndDlgResultFile <>& null & @wndDlgResultFile <> "")
		var document: @Document
		switch(@wndDlgResultType)
		case 0
			do document :: #@DocumentSrc
		case 1
			do document :: #@DocumentArWnd
		end switch
		do document.init(null)
		if(@saveSrc(@wndDlgResultFile, document.getSrc()))
			do @add(@wndDlgResultFile)
			do @updateUi()
			; TODO: Exchange the files.
		end if
	end if
	do @wndDlg :: null
	do @wndDlgResultFile :: null
	do @wndDlgEditFile :: null
	do @wndDlgListType :: null

	func btnFileOnPush(wnd: wnd@WndBase)
		var path: []char :: wnd@saveFileDialog(@wndDlg, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0, "kn")
		if(path <>& null)
			do @wndDlgEditFile.setText(path)
		end if
	end func

	func btnAddOnPush(wnd: wnd@WndBase)
		do @wndDlgResultFile :: @wndDlgEditFile.getText().replace("\\", "/")
		do @wndDlgResultType :: @wndDlgListType.getSel()
		do @wndDlg.close()
	end func
end func

func addExistingFile()
	if(@mainSrcDir = "")
		do wnd@msgBox(@wndMain, @langEn ?("The main source file must be saved before adding another file.", "ファイルを追加する前にメインソースファイルを保存しなければなりません。"), @title, %err, %ok)
		ret
	end if
	var file: []char :: wnd@openFileDialog(@wndMain, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0)
	if(file <>& null)
		do @add(file)
		do @updateUi()
		; TODO: Exchange the files.
	end if
end func

func arBaseParseWord(src: []char, ptr: &int): []char
	var last: int :: ptr
	while(last < ^src & src[last] <> ',')
		do last :+ 1
	end while
	var word: []char :: src.sub(ptr, last - ptr)
	do ptr :: last + 1
	ret word
end func

func lockEditor(lock: bool)
	do @lockingEditor :: lock
	do @btnCompile.enable(!lock)
	do @btnRls.enable(!lock)
end func

func updateLog()
	do @editHint.setText(@textErr ~ (@textErr =& null ?("", "\n\n")) ~ @textHint ~ (@textHint =& null ?("", "\n\n")) ~ @textFunc)
	do @editLog.setText(@textLog)
end func

class GetDocumentNameClass()
	+var src: []char
	+var document: @Document
end class

func getDocumentName(document: @Document): []char
	var getSrcClass: @GetDocumentNameClass :: #@GetDocumentNameClass
	do getSrcClass.src :: null
	do getSrcClass.document :: document
	do @documents.forEach(callback, getSrcClass)
	ret getSrcClass.src

	func callback(src: []char, document: @Document, param: @GetDocumentNameClass): bool
		if(document =& param.document)
			do param.src :: src
			ret false
		end if
		ret true
	end func
end func

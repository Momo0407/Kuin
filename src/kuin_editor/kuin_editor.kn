; Kuin Editor
; (C)Kuina-chan

func [d0917.knd, BuildMem] build(path: []char, funcGetSrc: func<([]char): [][]char>, sysDir: []char, output: []char, icon: []char, rls_: bool, env: []char, funcLog: func<([][]char, int, int)>): bool
end func

func [d0917.knd, Interpret1] interpret1(src: [][]char, color: [][]bit8)
end func

func [d0917.knd, Interpret2] interpret2(path: []char, funcGetSrc: func<([]char): [][]char>, sysDir: []char, env: []char, funcLog: func<([][]char, int, int)>)
end func

func [d0917.knd, Version] version(major: &int, minor: &int, micro: &int)
end func

func [d0917.knd, InitMemAllocator] initMemAllocator()
end func

func [d0917.knd, FinMemAllocator] finMemAllocator()
end func

func [d0917.knd, ResetMemAllocator] resetMemAllocator()
end func

func [d0917.knd, FreeIdentifierSet] freeIdentifierSet()
end func

func [d0917.knd, GetHint] getHint(name: []char, src: []char, row: int): []char
end func

const undoBufSize: int :: 1024
const fontSize: int :: 11
const cellWidth: int :: 9
const cellHeight: int :: 18

const colorBack: int :: 16#FFFFF5F5
const colorLineNumber: int :: 16#FFFF7F7F
const colorAreaBack: int :: 16#FF808080
const colorErrBack: int :: 16#FFFF3333

var wndMain: wnd@Wnd
var treeItem: wnd@Tree
var listInfo: wnd@List
var tabSrc: wnd@Tab
var drawEditor: wnd@Draw
var scrollXSrc: wnd@ScrollX
var scrollYSrc: wnd@ScrollY
var editLog: wnd@EditMulti
var btnCompile: wnd@Btn
var groupEnv: wnd@Group
var radioEnvWnd: wnd@Radio
var radioEnvCui: wnd@Radio
var btnRls: wnd@Btn
var editFile: wnd@Edit
var listFile: wnd@List
var menuMain: wnd@Menu
var popupMainFile: wnd@Popup
var popupMainBuild: wnd@Popup
var popupMainHelp: wnd@Popup

class Src()
	+var src: [][]char
	+var color: [][]bit8
end class

enum CharColor
	none
	identifier
	global
	reserved
	number
	str
	char_
	lineComment
	comment
	symbol
	max
end enum

enum UndoKind
	ins
	bs
	del
end enum

class Undo()
	+var kind: @UndoKind
	+var x: int
	+var y: int
	+var str: []char
end class

class Pos()
	+var src: []char
	+var row: int
	+var col: int

	+*func cmp(t: @Pos): int
		var result: int :: me.src.cmp(t.src)
		if(result <> 0)
			ret result
		end if
		do result :: me.row - t.row
		if(result <> 0)
			ret result
		end if
		ret me.col - t.col
	end func
end class

var srcs: dict<[]char, @Src>
var mainSrcName: []char
var curSrc: @Src
var undoBuf: []@Undo
var redoBuf: []@Undo
var undoPtr: int
var changed: bool
var dirty: int
var dirtyTime: int
var hint: bool
var hintTime : int
var lineNumberWidth: int
var pageX: int
var pageY: int
var cursorX: int
var cursorY: int
var areaX: int
var areaY: int
var drag: bool
var charColor: []int
var auxiliaryErr: dict<@Pos, []char>

var font: draw@Font

func main()
	do @initMemAllocator()

	do wnd@onKeyPress(@onKeyPress)

	do makeWnd()
	do initEditor()

	if(^lib@cmdLine() > 0)
		do @open(lib@cmdLine()[0].replace('\\', '/'))
	else
		do @new(null, null)
	end if

	while(wnd@act())
		switch(@dirty)
		case 0
			if(lib@sysTime() - @dirtyTime > 150)
				do @interpret1(@curSrc.src, @curSrc.color)
				do @drawEditor.paint()
				do @dirty :: 1
			end if
		case 1
			if(lib@sysTime() - @dirtyTime > 1200)
				do @resetMemAllocator()
				do @resetAuxiliary()
				try
					do @interpret2(@mainSrcName, @getSrc, null, @getEnv(), @logForInterpret)
				catch
				end try
				do @updateAuxiliary()
				do @dirty :: 2
			end if
		end switch
		if(@hint)
			if(lib@sysTime() - @hintTime > 50 & @dirty >= 1)
				do @showHint()
				do @hint :: false
			end if
		end if
	end while

	do @finMemAllocator()
	do @freeIdentifierSet()

	func makeWnd()
		do @wndMain :: wnd@makeWnd(null, %normal, 1224, 768, "Kuin Programming Language")
		do @wndMain.minMax(384, 640, -1, -1)
		do @wndMain.onClose :: @wndMainOnClose
		do @wndMain.onPushMenu :: @wndMainOnPushMenu
		do @treeItem :: wnd@makeTree(@wndMain, 12, 12, 194, 366, %fix, %fix)
		do @listInfo :: wnd@makeList(@wndMain, 12, 384, 194, 372, %fix, %scale)
		do @tabSrc :: wnd@makeTab(@wndMain, 212, 12, 809, 603, %scale, %scale)
		do @drawEditor :: wnd@makeDraw(@tabSrc, 6, 6, 797, 591, %scale, %scale, true)
		do @drawEditor.onPaint :: @drawEditorOnPaint
		do @drawEditor.onMouseDownL :: @drawEditorOnMouseDownL
		do @drawEditor.onMouseUpL :: @drawEditorOnMouseUpL
		do @drawEditor.onMouseMove :: @drawEditorOnMouseMove
		do @drawEditor.onFocus :: @drawEditorOnFocus
		do @drawEditor.onKeyDown :: @drawEditorOnKeyDown
		do @drawEditor.onKeyChar :: @drawEditorOnKeyChar
		do @drawEditor.onScrollX :: @drawEditorOnScrollX
		do @drawEditor.onScrollY :: @drawEditorOnScrollY
		do @scrollXSrc :: wnd@makeScrollX(@drawEditor, 0, 574, 780, 17, %scale, %move)
		do @scrollXSrc.setState(0, 0, 1, 0)
		do @scrollYSrc :: wnd@makeScrollY(@drawEditor, 780, 0, 17, 574, %move, %scale)
		do @scrollYSrc.setState(0, 0, 1, 0)
		do @editLog :: wnd@makeEditMulti(@wndMain, 212, 621, 1000, 135, %scale, %move)
		do @editLog.readonly(true)
		do @btnCompile :: wnd@makeBtn(@wndMain, 1027, 12, 185, 23, %move, %fix, "Compile && Run")
		do @btnCompile.onPush :: @btnCompileOnPush
		do @groupEnv :: wnd@makeGroup(@wndMain, 1027, 41, 185, 62, %move, %fix, "Environment")
		do @radioEnvWnd :: wnd@makeRadio(@groupEnv, 6, 18, 173, 16, %fix, %fix, "Window")
		do @radioEnvWnd.setChk(true)
		do @radioEnvCui :: wnd@makeRadio(@groupEnv, 6, 40, 173, 16, %fix, %fix, "CUI")
		do @btnRls :: wnd@makeBtn(@wndMain, 1027, 109, 185, 23, %move, %fix, "Release Build...")
		do @btnRls.onPush :: @btnRlsOnPush
		do @editFile :: wnd@makeEdit(@wndMain, 1027, 359, 185, 19, %move, %fix)
		do @editFile.readonly(true)
		do @listFile :: wnd@makeList(@wndMain, 1027, 384, 185, 231, %move, %scale)
		do @menuMain :: wnd@makeMenu()
		do @popupMainFile :: wnd@makePopup()
		do @popupMainFile.add(16#0001, "&New\tCtrl+N")
		do @popupMainFile.add(16#0002, "&Load...\tCtrl+O")
		do @popupMainFile.addLine()
		do @popupMainFile.add(16#0003, "&Save All\tCtrl+S")
		do @popupMainFile.add(16#0004, "Save &As...\tCtrl+Shift+S")
		do @popupMainFile.addLine()
		do @popupMainFile.add(16#0005, "E&xit\tCtrl+Q")
		do @menuMain.addPopup("&File", @popupMainFile)
		do @popupMainBuild :: wnd@makePopup()
		do @popupMainBuild.add(16#0020, "&Compile && Run\tF5")
		do @popupMainBuild.addLine()
		do @popupMainBuild.add(16#0021, "&Release Build...\tCtrl+Shift+B")
		do @menuMain.addPopup("&Build", @popupMainBuild)
		do @popupMainHelp :: wnd@makePopup()
		do @popupMainHelp.add(16#0010, "&View Help\tF1")
		do @popupMainHelp.addLine()
		do @popupMainHelp.add(16#0011, "&About Kuin...")
		do @menuMain.addPopup("&Help", @popupMainHelp)
		do @wndMain.setMenu(@menuMain)
	end func

	func initEditor()
		do @charColor :: #[%max $ @CharColor $ int]int
		do @charColor[%none $ @CharColor $ int] :: 16#FF999999
		do @charColor[%identifier $ @CharColor $ int] :: 16#FF009BEA
		do @charColor[%global $ @CharColor $ int] :: 16#FFCC00F6
		do @charColor[%reserved $ @CharColor $ int] :: 16#FF1400F6
		do @charColor[%number $ @CharColor $ int] :: 16#FFEA0062
		do @charColor[%str $ @CharColor $ int] :: 16#FFEA0062
		do @charColor[%char_ $ @CharColor $ int] :: 16#FFEA0062
		do @charColor[%lineComment $ @CharColor $ int] :: 16#FF1EB000
		do @charColor[%comment $ @CharColor $ int] :: 16#FF1EB000
		do @charColor[%symbol $ @CharColor $ int] :: 16#FF666666
		do @font :: draw@makeFont("Consolas", @fontSize, false, false, false, @cellWidth $ float)
	end func
end func

func onKeyPress(key: input@Key, shiftCtrl: wnd@ShiftCtrl): bool
	switch(shiftCtrl)
	case %none
		switch(key)
		case %f1
			do @wndMainOnPushMenu(@wndMain, 16#0011)
			ret true
		case %f5
			do @wndMainOnPushMenu(@wndMain, 16#0020)
			ret true
		end switch
	case %shift
		switch(key)
		end switch
	case %ctrl
		switch(key)
		case %n
			do @wndMainOnPushMenu(@wndMain, 16#0001)
			ret true
		case %o
			do @wndMainOnPushMenu(@wndMain, 16#0002)
			ret true
		case %s
			do @wndMainOnPushMenu(@wndMain, 16#0003)
			ret true
		case %q
			do @wndMainOnPushMenu(@wndMain, 16#0005)
			ret true
		end switch
	case %shiftCtrl
		switch(key)
		case %b
			do @wndMainOnPushMenu(@wndMain, 16#0021)
			ret true
		case %s
			do @wndMainOnPushMenu(@wndMain, 16#0004)
			ret true
		end switch
	end switch
	ret false
end func

func refreshCursor(moveRight: bool, refreshScroll: bool)
	var scrWidth: int
	var scrHeight: int
	do @drawEditor.getSize(&scrWidth, &scrHeight)
	do @lineNumberWidth :: @cellWidth * (log10(^@curSrc.src) + 1)

	if(@cursorX < 0)
		do @cursorX :: lib@intMax
		do @cursorY :- 1
	end if
	if(@cursorY < 0)
		do @cursorX :: 0
		do @cursorY :: 0
	end if
	if(@cursorY > ^@curSrc.src - 1)
		do @cursorY :: ^@curSrc.src - 1
		do @cursorX :: ^@curSrc.src[@cursorY]
	else
		if(@cursorX > ^@curSrc.src[@cursorY])
			if(moveRight & @cursorY <> ^@curSrc.src - 1)
				do @cursorX :: 0
				do @cursorY :+ 1
			else
				do @cursorX :: ^@curSrc.src[@cursorY]
			end if
		end if
	end if
	if(!@drag & @areaX = @cursorX & @areaY = @cursorY)
		do @areaX :: -1
	end if

	if(refreshScroll)
		var paddingX: int :: (@lineNumberWidth + 17) / @cellWidth + 1
		const paddingY: int :: 17 / @cellHeight + 1
		if(@pageY > @cursorY)
			do @pageY :: @cursorY
		end if
		if(@pageY < @cursorY - scrHeight / @cellHeight + paddingY)
			do @pageY :: @cursorY - scrHeight / @cellHeight + paddingY
		end if
		do @scrollYSrc.setState(0, ^@curSrc.src - 1 + paddingY, scrHeight / @cellHeight, @pageY)
		var maxX: int :: 0
		for i(0, scrHeight / @cellHeight + 1)
			if(@pageY + i >= ^@curSrc.src)
				break i
			end if
			var x: int :: 0
			var str: []char :: @curSrc.src[@pageY + i]
			for j(0, ^str - 1)
				do x :+ @charWidth(str[j], x)
			end for
			if(maxX < x)
				do maxX :: x
			end if
		end for
		block
			var x: int :: 0
			for i(0, ^@curSrc.src[@cursorY] - 1)
				if(i >= @cursorX)
					break i
				end if
				do x :+ @charWidth(@curSrc.src[@cursorY][i], x)
			end for
			if(@pageX > x)
				do @pageX :: x
			end if
			if(@pageX < x - scrWidth / @cellWidth + paddingX)
				do @pageX :: x - scrWidth / @cellWidth + paddingX
			end if
		end block
		do @scrollXSrc.setState(0, maxX - 1 + paddingX, scrWidth / @cellWidth, @pageX)
	end if

	block
		var x: int :: 0
		var str: []char :: @curSrc.src[@cursorY]
		for i(0, @cursorX - 1)
			do x :+ @charWidth(str[i], x)
		end for
		do x :: @lineNumberWidth + (x - @pageX) * @cellWidth
		var y: int :: (@cursorY - @pageY) * @cellHeight
		if(x + 2 <= 0 | scrWidth - 17 <= x | y + @cellHeight <= 0 | scrHeight - 17 <= y)
			do @drawEditor.moveCaret(-1, -1)
		else
			do @drawEditor.moveCaret(x, y)
		end if
	end block

	do @setHint()

	func log10(n: int): int
		var result: int :: 0
		var m: int :: 1
		while(n >= m)
			do m :* 10
			do result :+ 1
		end while
		ret result
	end func
end func

func wndMainOnPushMenu(wnd: wnd@WndBase, id: int)
	switch(id)
	case 16#0001
		if (@chkChanged())
			do @new(null, null)
		end if
	case 16#0002
		if (@chkChanged())
			var file: []char :: wnd@openFileDialog(@wndMain, ["Kuin source code (*.kn)", "*.kn"], 0)
			if(file <>& null)
				do @open(file)
			end if
		end if
	case 16#0003
		do @save(false)
	case 16#0004
		do @save(true)
	case 16#0005
		do @wndMain.close()
	case 16#0010
		do wnd@msgBox(@wndMain, "Good luck!", "Kuin Programming Language", %info, %ok)
	case 16#0011
		block
			var major: int
			var minor: int
			var micro: int
			do @version(&major, &minor, &micro)
			do wnd@msgBox(@wndMain, "Kuin Programming Language\nVersion \{major}.\{minor}.\{micro}\n(C)Kuina-chan", "Kuin Programming Language", %info, %ok)
		end block
	case 16#0020
		do @btnCompileOnPush(@btnCompile)
	case 16#0021
		do @btnRlsOnPush(@btnRls)
	end switch
end func

func wndMainOnClose(wnd: wnd@WndBase): bool
	ret @chkChanged()
end func

func btnCompileOnPush(wnd: wnd@WndBase)
	var tmp: []char :: file@sysDir(%appData) ~ "Kuin/tmp/"
	var out: []char :: tmp ~ "out.exe"
	try
		do file@makeDir(tmp)
	catch
		do wnd@msgBox(@wndMain, "Could not delete: " ~ tmp, "Kuin Programming Language", %error, %ok)
		ret
	end try
	do @resetMemAllocator()
	do @editLog.setText("")
	var cmd: []char
	var cmdLine: []char
	if(@radioEnvWnd.getChk())
		do cmd :: out
		do cmdLine :: null
	elif(@radioEnvCui.getChk())
		do cmd :: file@sysDir(%system32) ~ "cmd.exe"
		do cmdLine :: "/C \"\"" ~ file@exeDir().replace('/', '\\') ~ "sys\\launcher.bat\" \"" ~ out.replace('/', '\\') ~ "\"\""
	end if
	try
		do @resetAuxiliary()
		if(@build(@mainSrcName, @getSrc, null, out, null, false, @getEnv(), @log))
			if (@mainSrcName <> "_default_.kn")
				var filePtr: file@Writer :: file@makeWriter(tmp ~ "_curdir_.txt", false)
				do filePtr.writeStr(file@dir(@mainSrcName))
				do filePtr.writeChar('\n')
				do filePtr.fin()
			end if
			var process: task@Process :: task@makeProcess(cmd, cmdLine)
			if(process <>& null)
				do process.run(false)
			end if
		end if
		do @updateAuxiliary()
	catch
		do wnd@msgBox(@wndMain, "Unexpected error.", "Kuin Programming Language", %error, %ok)
	end try
end func

func btnRlsOnPush(wnd: wnd@WndBase)
	var file: []char :: wnd@saveFileDialog(@wndMain, ["Executable file (*.exe)", "*.exe"], 0, "exe")
	if(file =& null)
		ret
	end if
	do @resetMemAllocator()
	do @editLog.setText("")
	try
		do @resetAuxiliary()
		if(@build(@mainSrcName, @getSrc, null, file, null, true, @getEnv(), @log))
			if (@mainSrcName <> "_default_.kn")
				var resSrc: []char :: file@dir(@mainSrcName) ~ "res/"
				if(file@exist(resSrc))
					var resDst: []char :: file@dir(file) ~ "res/"
					do file@delDir(resDst)
					do file@copyDir(resDst, resSrc)
				end if
			end if
			do wnd@msgBox(@wndMain, "The build succeeded.", "Kuin Programming Language", %info, %ok)
		end if
		do @updateAuxiliary()
	catch
		do wnd@msgBox(@wndMain, "Unexpected error.", "Kuin Programming Language", %error, %ok)
	end try
end func

func getEnv(): []char
	if(@radioEnvWnd.getChk())
		ret "wnd"
	elif(@radioEnvCui.getChk())
		ret "cui"
	end if
	ret "wnd"
end func

func getSrc(path: []char): [][]char
	var result: @Src :: @srcs.get(path)
	if(result <>& null)
		ret result.src
	end if

	var filePtr: file@Reader :: file@makeReader(path)
	if(filePtr =& null)
		ret null
	end if
	do filePtr.delimiter("")
	var src: list<[]char> :: #list<[]char>
	while(!filePtr.term())
		do src.add(filePtr.readLine())
	end while
	do filePtr.fin()
	var result2: [][]char :: src.toArray()
	var newSrc: @Src :: #@Src
	do newSrc.src :: result2
	do @srcs.add(##path, newSrc)
	ret result2
end func

func log(args: [][]char, row: int, col: int)
	var msg: []char :: @nullStr(args[0]) ~ ": " ~ @nullStr(args[1])
	if(args[2] =& null)
		do @editLog.setText(@editLog.getText() ~ msg ~ "\n")
	else
		do @editLog.setText(@editLog.getText() ~ msg ~ " (" ~ @srcStr(args[2]) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ ")\n")
		var pos: @Pos :: #@Pos
		do pos.src :: ##args[2]
		do pos.row :: row
		do pos.col :: col
		if(!@auxiliaryErr.exist(pos))
			do @auxiliaryErr.add(pos, @nullStr(args[0]) ~ " (" ~ @srcStr(args[2]) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ ")")
		end if
	end if
end func

func logForInterpret(args: [][]char, row: int, col: int)
	if(args[2] <>& null)
		var pos: @Pos :: #@Pos
		do pos.src :: ##args[2]
		do pos.row :: row
		do pos.col :: col
		if(!@auxiliaryErr.exist(pos))
			do @auxiliaryErr.add(pos, @nullStr(args[0]) ~ " (" ~ @srcStr(args[2]) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ ")")
		end if
	end if
end func

func nullStr(s: []char): []char
	ret s =& null ?("(null)", s)
end func

func srcStr(s: []char): []char
	if(s =& null)
		ret "(null)"
	elif(s = "\\_default_")
		ret "Untitled"
	end if
	ret s
end func

func chkChanged(): bool
	if(!@changed)
		ret true
	end if
	var result: wnd@MsgBoxResult :: wnd@msgBox(@wndMain, "Do you want to save changes to " ~ (@mainSrcName = "_default_.kn" ?("Untitled", @mainSrcName)) ~ "?", "Kuin Programming Language", %warn, %yesNoCancel)
	if(result = %cancel)
		ret false
	elif(result = %no)
		ret true
	end if
	ret @save(false)
end func

func new(srcName: []char, src: [][]char)
	do @editLog.setText("")
	do @srcs :: #dict<[]char, @Src>

	do @curSrc :: #@Src
	if(src =& null | ^src = 0)
		do @curSrc.src :: [""]
		do @curSrc.color :: [#[0]bit8]
	else
		do @curSrc.src :: src
		do @curSrc.color :: #[^src][]bit8
		for i(0, ^src - 1)
			do @curSrc.color[i] :: #[^src[i]]bit8
		end for
	end if

	do @mainSrcName :: srcName =& null ?("_default_.kn", srcName)
	do @srcs.add(@mainSrcName, @curSrc)
	do @editFile.setText(srcName =& null ?("No Title", srcName))

	do @undoBuf :: #[@undoBufSize]@Undo
	do @redoBuf :: #[@undoBufSize]@Undo
	do @undoPtr :: 0

	do @pageX :: 0
	do @pageY :: 0
	do @cursorX :: 0
	do @cursorY :: 0
	do @areaX :: -1
	do @areaY :: -1
	do @drag :: false

	do @setDirty()
	do @changed :: false
	do @setHint()

	do @resetAuxiliary()
	do @refreshCursor(false, true)
	do @drawEditor.paint()
end func

func open(file: []char)
	var src: list<[]char> :: #list<[]char>
	var filePtr: file@Reader :: file@makeReader(file)
	if(filePtr =& null)
		do file :: null
	else
		while(!filePtr.term())
			do src.add(filePtr.readLine())
		end while
		do filePtr.fin()
	end if
	do @new(file, src.toArray())
end func

func save(new: bool): bool
	if(!new & !@changed)
		ret true
	end if
	var file: []char
	if(new | @mainSrcName = "_default_.kn")
		do file :: wnd@saveFileDialog(@wndMain, ["Kuin source code (*.kn)", "*.kn"], 0, "kn")
		if(file =& null)
			ret false
		end if
		do @mainSrcName :: file
		do @editFile.setText(@mainSrcName)
	else
		do file :: @mainSrcName
	end if
	var filePtr: file@Writer :: file@makeWriter(file, false)
	for line(0, ^@curSrc.src - 1)
		do filePtr.writeStr(@curSrc.src[line])
		if(line <> ^@curSrc.src - 1 | @curSrc.src[line] <> "")
			do filePtr.writeChar('\n')
		end if
	end for
	do filePtr.fin()
	do @changed :: false
	ret true
end func

func charWidth(c: char, x: int): int
	if(c = '\t')
		ret 4 - x % 4
	elif(c $ int <= 16#1F)
		ret 0
	elif(c $ int <= 16#7E)
		ret 1
	elif(c $ int <= 16#A0)
		ret 0
	end if
	ret 2
end func

func setDirty()
	do @changed :: true
	do @dirty :: 0
	do @dirtyTime :: lib@sysTime()
end func

func setHint()
	do @hint :: true
	do @hintTime :: lib@sysTime()
end func

func areaSelected(): bool
	ret @areaX <> -1 & (@areaX <> @cursorX | @areaY <> @cursorY)
end func

func setArea(shiftCtrl: wnd@ShiftCtrl)
	if(shiftCtrl = %shift | shiftCtrl = %shiftCtrl)
		if(!@areaSelected())
			do @areaX :: @cursorX
			do @areaY :: @cursorY
		end if
	else
		do @areaX :: -1
	end if
end func

func delAreaStr()
	assert @areaSelected()
	var x1: int :: @areaX
	var y1: int :: @areaY
	var x2: int :: @cursorX
	var y2: int :: @cursorY
	if(y1 > y2 | y1 = y2 & x1 > x2)
		do x1 :$ x2
		do y1 :$ y2
	end if
	var len: int
	if(y1 = y2)
		do len :: x2 - x1
	else
		do len :: ^@curSrc.src[y1] - x1 + 1
		for i(y1 + 1, y2 - 1)
			do len :+ ^@curSrc.src[i] + 1
		end for
		do len :+ x2
	end if
	do @cursorX :: x1
	do @cursorY :: y1
	do @del(@cursorX, @cursorY, len, true)
	do @areaX :: -1
end func

func copyAreaStr()
	assert @areaSelected()
	var x1: int :: @areaX
	var y1: int :: @areaY
	var x2: int :: @cursorX
	var y2: int :: @cursorY
	if(y1 > y2 | y1 = y2 & x1 > x2)
		do x1 :$ x2
		do y1 :$ y2
	end if
	var str: []char
	if(y1 = y2)
		do str :: @curSrc.src[y1].sub(x1, x2 - x1)
	else
		do str :: @curSrc.src[y1].sub(x1, -1) ~ "\n"
		for i(y1 + 1, y2 - 1)
			do str :~ @curSrc.src[i] ~ "\n"
		end for
		do str :~ @curSrc.src[y2].sub(0, x2)
	end if
	do wnd@setClipboardStr(str)
end func

func mousePosToCharPos(mouseX: int, mouseY: int)
	do @cursorY :: @pageY + mouseY / @cellHeight
	if(@cursorY >= ^@curSrc.src)
		do @cursorX :: 0
		ret
	end if
	var left: int :: @lineNumberWidth - @pageX * @cellWidth
	var x: int :: 0
	for i(0, ^@curSrc.src[@cursorY] - 1)
		var charWidth: int :: @charWidth(@curSrc.src[@cursorY][i], x)
		if(mouseX < left + (x + charWidth) * @cellWidth)
			do @cursorX :: i
			ret
		end if
		do x :+ charWidth
	end for
	do @cursorX :: ^@curSrc.src[@cursorY]
end func

func undoPtrPrev(ptr: int): int
	ret ptr = 0 ?(@undoBufSize - 1, ptr - 1)
end func

func undoPtrNext(ptr: int): int
	ret ptr = @undoBufSize - 1 ?(0, ptr + 1)
end func

func ins(x: int, y: int, str: []char, recordUndo: bool)
	if(recordUndo)
		do @undoPtr :: @undoPtrNext(@undoPtr)
		var redo: @Undo :: #@Undo
		do redo.kind :: %ins
		do redo.x :: x
		do redo.y :: y
		do redo.str :: str
		do @redoBuf[@undoPtr] :: redo
	end if
	foreach c(str)
		if(c = '\n')
			var line: []char :: @curSrc.src[y].sub(x, -1)
			do @curSrc.src[y] :: @curSrc.src[y].sub(0, x)
			do @curSrc.color[y] :: #[^@curSrc.src[y]]bit8
			do @curSrc.src :: @curSrc.src.sub(0, y + 1) ~ [line] ~ @curSrc.src.sub(y + 1, -1)
			do @curSrc.color :: @curSrc.color.sub(0, y + 1) ~ [#[^line]bit8] ~ @curSrc.color.sub(y + 1, -1)
			do x :: 0
			do y :+ 1
		else
			do @curSrc.src[y] :: @curSrc.src[y].sub(0, x) ~ c.toStr() ~ @curSrc.src[y].sub(x, -1)
			do @curSrc.color[y] :: #[^@curSrc.src[y]]bit8
			do x :+ 1
		end if
	end foreach
	if(recordUndo)
		var undo: @Undo :: #@Undo
		do undo.kind :: %bs
		do undo.x :: x
		do undo.y :: y
		do undo.str :: (^str).toStr()
		do @undoBuf[@undoPtr] :: undo
	end if
	do @cursorX :: x
	do @cursorY :: y
	do @setDirty()
end func

func bs(x: int, y: int, len: int, recordUndo: bool)
	if(recordUndo)
		do @undoPtr :: @undoPtrNext(@undoPtr)
		var redo: @Undo :: #@Undo
		do redo.kind :: %bs
		do redo.x :: x
		do redo.y :: y
		do redo.str :: len.toStr()
		do @redoBuf[@undoPtr] :: redo
	end if
	var undoStr: []char :: ""
	for(1, len)
		if(x = 0)
			if(y <> 0)
				do undoStr :: "\n" ~ undoStr
				var x2: int :: ^@curSrc.src[y - 1]
				do @curSrc.src[y - 1] :~ @curSrc.src[y]
				do @curSrc.color[y - 1] :: #[^@curSrc.src[y - 1]]bit8
				do @curSrc.src :: @curSrc.src.sub(0, y) ~ @curSrc.src.sub(y + 1, -1)
				do @curSrc.color :: @curSrc.color.sub(0, y) ~ @curSrc.color.sub(y + 1, -1)
				do y :- 1
				do x :: x2
			end if
		else
			do undoStr :: @curSrc.src[y][x - 1].toStr() ~ undoStr
			do @curSrc.src[y] :: @curSrc.src[y].sub(0, x - 1) ~ @curSrc.src[y].sub(x, -1)
			do @curSrc.color[y] :: #[^@curSrc.src[y]]bit8
			do x :- 1
		end if
	end for
	if(recordUndo)
		var undo: @Undo :: #@Undo
		do undo.kind :: %ins
		do undo.x :: x
		do undo.y :: y
		do undo.str :: undoStr
		do @undoBuf[@undoPtr] :: undo
	end if
	do @cursorX :: x
	do @cursorY :: y
	do @setDirty()
end func

func del(x: int, y: int, len: int, recordUndo: bool)
	if(recordUndo)
		do @undoPtr :: @undoPtrNext(@undoPtr)
		var redo: @Undo :: #@Undo
		do redo.kind :: %del
		do redo.x :: x
		do redo.y :: y
		do redo.str :: len.toStr()
		do @redoBuf[@undoPtr] :: redo
	end if
	var undoStr: []char :: ""
	for(1, len)
		if(x = ^@curSrc.src[y])
			if(y <> ^@curSrc.src - 1)
				do undoStr :~ "\n"
				do @curSrc.src[y] :~ @curSrc.src[y + 1]
				do @curSrc.color[y] :: #[^@curSrc.src[y]]bit8
				do @curSrc.src :: @curSrc.src.sub(0, y + 1) ~ @curSrc.src.sub(y + 2, -1)
				do @curSrc.color :: @curSrc.color.sub(0, y + 1) ~ @curSrc.color.sub(y + 2, -1)
			end if
		else
			do undoStr :~ @curSrc.src[y][x].toStr()
			do @curSrc.src[y] :: @curSrc.src[y].sub(0, x) ~ @curSrc.src[y].sub(x + 1, -1)
			do @curSrc.color[y] :: #[^@curSrc.src[y]]bit8
		end if
	end for
	if(recordUndo)
		var undo: @Undo :: #@Undo
		do undo.kind :: %ins
		do undo.x :: x
		do undo.y :: y
		do undo.str :: undoStr
		do @undoBuf[@undoPtr] :: undo
	end if
	do @cursorX :: x
	do @cursorY :: y
	do @setDirty()
end func

func undo()
	if(@undoBuf[@undoPtrPrev(@undoPtr)] =& null)
		ret
	end if
	while(true)
		do @undoPtr :: @undoPtrPrev(@undoPtr)
		if(@undoBuf[@undoPtr] =& null)
			ret
		end if
		do @doCmd(@undoBuf[@undoPtr])
	end while
end func

func redo()
	if(@redoBuf[@undoPtrNext(@undoPtr)] =& null)
		ret
	end if
	while(true)
		do @undoPtr :: @undoPtrNext(@undoPtr)
		if(@redoBuf[@undoPtr] =& null)
			ret
		end if
		do @doCmd(@redoBuf[@undoPtr])
	end while
end func

func doCmd(cmd: @Undo)
	switch(cmd.kind)
	case %ins
		do @ins(cmd.x, cmd.y, cmd.str, false)
	case %bs
		do @bs(cmd.x, cmd.y, cmd.str.toInt(), false)
	case %del
		do @del(cmd.x, cmd.y, cmd.str.toInt(), false)
	default
		assert false
	end switch
end func

func addUndoMark()
	do @undoPtr :: @undoPtrNext(@undoPtr)
	var next: int :: @undoPtrNext(@undoPtr)
	do @undoBuf[@undoPtr] :: null
	do @undoBuf[next] :: null
	do @redoBuf[@undoPtr] :: null
	do @redoBuf[next] :: null
end func

func drawEditorOnPaint(wnd: wnd@WndBase, width: int, height: int)
	do draw@rect(0.0, 0.0, width $ float, height $ float, @colorBack)
	; TODO: Draw the line.
	for i(0, ^@curSrc.src - 1)
		var y: float :: (i * @cellHeight) $ float
		if(y < -@cellHeight $ float | y >= (height + @cellHeight) $ float)
			skip i
		end if
		var str: []char :: (@pageY + i + 1).toStr()
		do @font.draw((@lineNumberWidth - (^str + 1) * @cellWidth + @cellWidth / 2) $ float, y, str, @colorLineNumber)
	end for

	var areaX1: int :: @areaX
	var areaY1: int :: @areaY
	var areaX2: int :: @cursorX
	var areaY2: int :: @cursorY
	if(@areaSelected() & (areaY1 > areaY2 | areaY1 = areaY2 & areaX1 > areaX2))
		do areaX1 :$ areaX2
		do areaY1 :$ areaY2
	end if
	for i(0, height / @cellHeight)
		if(@pageY + i >= ^@curSrc.src)
			break i
		end if
		var str: []char :: @curSrc.src[@pageY + i]
		var left: int :: @lineNumberWidth - @pageX * @cellWidth
		var x: int :: 0
		for j(0, ^str)
			assert j = ^str | str[j] <> 16#01 $ char & str[j] <> '\n'
			var x2: int :: left + x * @cellWidth
			if(x2 >= width)
				break j
			end if
			if(x2 >= @lineNumberWidth)
				var inArea: bool :: false
				if(@areaSelected())
					var areaX3: int :: j
					var areaY3: int :: @pageY + i
					if (areaY3 < areaY1 | areaY2 < areaY3)
						; Do nothing.
					elif(areaY1 < areaY3 & areaY3 < areaY2)
						do inArea :: true
					elif(areaY1 = areaY2)
						do inArea :: areaX1 <= areaX3 & areaX3 < areaX2
					elif(areaY3 = areaY1)
						do inArea :: areaX1 <= areaX3
					else
						assert areaY3 = areaY2
						do inArea :: areaX3 < areaX2
					end if
				end if
				var textX: float :: x2 $ float
				var textY: float :: (i * @cellHeight) $ float
				if(j = ^str)
					if(inArea)
						do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, @colorAreaBack)
					end if
					; TODO: Return mark.
				elif(inArea)
					do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, @colorAreaBack)
					do @font.draw(textX, textY, str[j].toStr(), draw@white)
				elif(@curSrc.color[@pageY + i][j].and(16#80b8) <> 0 $ @CharColor $ bit8)
					do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, @colorErrBack)
					do @font.draw(textX, textY, str[j].toStr(), draw@white)
				else
					do @font.draw(textX, textY, str[j].toStr(), @charColor[@curSrc.color[@pageY + i][j].and(16#7Fb8) $ int])
				end if
			end if
			if(j <> ^str)
				do x :+ @charWidth(str[j], x)
			end if
		end for
	end for
	do draw@render(0)
end func

func drawEditorOnMouseDownL(wnd: wnd@WndBase, x: int, y: int)
	do @setArea(input@getKey(%shift) ?(%shift $ wnd@ShiftCtrl, %none))
	do @drag :: true
	do @mousePosToCharPos(x, y)
	do @refreshCursor(false, true)
	if(!@areaSelected())
		do @areaX :: @cursorX
		do @areaY :: @cursorY
	end if
	do @drawEditor.paint()
end func

func drawEditorOnMouseUpL(wnd: wnd@WndBase, x: int, y: int)
	do @drag :: false
	do @refreshCursor(false, true)
end func

func drawEditorOnMouseMove(wnd: wnd@WndBase, x: int, y: int)
	if(@drag)
		do @mousePosToCharPos(x, y)
		do @refreshCursor(false, true)
		do @drawEditor.paint()
	end if
end func

func drawEditorOnFocus(wnd: wnd@WndBase, focus: bool)
	if(focus)
		do @drawEditor.showCaret(@cellHeight, @font)
		do @refreshCursor(false, true)
	else
		do @drawEditor.hideCaret()
	end if
end func

func drawEditorOnKeyDown(wnd: wnd@WndBase, key: input@Key, shiftCtrl: wnd@ShiftCtrl)
	switch(key)
	case %a
		if(shiftCtrl = %ctrl)
			do @areaX :: 0
			do @areaY :: 0
			do @cursorX :: lib@intMax
			do @cursorY :: lib@intMax
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %c
		if(shiftCtrl = %ctrl & @areaSelected())
			do @copyAreaStr()
		end if
	case %v
		if(shiftCtrl = %ctrl)
			var str: []char :: wnd@getClipboardStr()
			if(str <>& null)
				if(@areaSelected())
					do @delAreaStr()
				end if
				do @ins(@cursorX, @cursorY, str, true)
				do @addUndoMark()
				do @refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		end if
	case %x
		if(shiftCtrl = %ctrl & @areaSelected())
			do @copyAreaStr()
			do @delAreaStr()
			do @addUndoMark()
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %z
		if(shiftCtrl = %ctrl)
			if(@areaSelected())
				do @areaX :: -1
			end if
			do @undo()
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		elif(shiftCtrl = %shiftCtrl)
			if(@areaSelected())
				do @areaX :: -1
			end if
			do @redo()
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %bs
		if(shiftCtrl = %none)
			if(@areaSelected())
				do @delAreaStr()
			else
				do @bs(@cursorX, @cursorY, 1, true)
			end if
			do @addUndoMark()
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %tab
		if(shiftCtrl = %none)
			if(!@areaSelected())
				do @ins(@cursorX, @cursorY, "\t", true)
				do @addUndoMark()
				do @refreshCursor(false, true)
				do @drawEditor.paint()
			else
				; TODO: Indent.
			end if
		end if
	case %enter
		if(shiftCtrl = %none)
			if(@areaSelected())
				do @delAreaStr()
			end if
			do @ins(@cursorX, @cursorY, "\n", true)
			do @addUndoMark()
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %pageUp
	case %pageDown
	case %end_
		do @setArea(shiftCtrl)
		do @cursorX :: lib@intMax
		if(shiftCtrl = %ctrl | shiftCtrl = %shiftCtrl)
			do @cursorY :: lib@intMax
		end if
		do @refreshCursor(false, true)
		do @drawEditor.paint()
	case %home
		do @setArea(shiftCtrl)
		do @cursorX :: 0
		if(shiftCtrl = %ctrl | shiftCtrl = %shiftCtrl)
			do @cursorY :: 0
		end if
		do @refreshCursor(false, true)
		do @drawEditor.paint()
	case %left
		if(shiftCtrl = %ctrl)
			; TODO
		else
			do @setArea(shiftCtrl)
			do @cursorX :- 1
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %up
		if(shiftCtrl = %ctrl)
			; TODO
		else
			do @setArea(shiftCtrl)
			var absoluteX: int :: getAbsoluteX()
			do @cursorY :- 1
			do setAbsoluteX(absoluteX)
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %right
		if(shiftCtrl = %ctrl)
			; TODO
		else
			do @setArea(shiftCtrl)
			do @cursorX :+ 1
			do @refreshCursor(true, true)
			do @drawEditor.paint()
		end if
	case %down
		if(shiftCtrl = %ctrl)
			; TODO
		else
			do @setArea(shiftCtrl)
			var absoluteX: int :: getAbsoluteX()
			do @cursorY :+ 1
			do setAbsoluteX(absoluteX)
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	case %ins
		; TODO: Insert mode.
	case %del
		if(shiftCtrl = %none)
			if(@areaSelected())
				do @delAreaStr()
			else
				do @del(@cursorX, @cursorY, 1, true)
			end if
			do @addUndoMark()
			do @refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end switch

	func getAbsoluteX(): int
		if(@cursorY < 0 | ^@curSrc.src <= @cursorY)
			ret 0
		end if
		var absoluteX: int :: 0
		for i(0, @cursorX - 1)
			if(i >= ^@curSrc.src[@cursorY])
				break i
			end if
			var charWidth: int :: @charWidth(@curSrc.src[@cursorY][i], absoluteX)
			do absoluteX :+ charWidth
		end for
		ret absoluteX
	end func

	func setAbsoluteX(absoluteX: int)
		if(@cursorY < 0 | ^@curSrc.src <= @cursorY)
			ret
		end if
		var x: int :: 0
		do @cursorX :: 0
		for i(0, ^@curSrc.src[@cursorY] - 1)
			var charWidth: int :: @charWidth(@curSrc.src[@cursorY][i], x)
			if(x + charWidth > absoluteX)
				break i
			end if
			do x :+ charWidth
			do @cursorX :+ 1
		end for
	end func
end func

func drawEditorOnKeyChar(wnd: wnd@WndBase, key: char)
	if(key = '\t' | @charWidth(key, 0) = 0)
		ret
	end if
	if(@areaSelected())
		do @delAreaStr()
	end if
	do @ins(@cursorX, @cursorY, [key], true)
	do @addUndoMark()
	do @refreshCursor(false, true)
	do @drawEditor.paint()
end func

func drawEditorOnScrollX(wnd: wnd@WndBase, pos: int)
	do @pageX :: pos
	do @refreshCursor(false, false)
	do @drawEditor.paint()
end func

func drawEditorOnScrollY(wnd: wnd@WndBase, pos: int)
	do @pageY :: pos
	do @refreshCursor(false, false)
	do @drawEditor.paint()
end func

func resetAuxiliary()
	do @auxiliaryErr :: #dict<@Pos, []char>
	do @listInfo.clear()
end func

func updateAuxiliary()
	do @auxiliaryErr.forEach(callback)
	do @drawEditor.paint()

	func callback(pos: @Pos, msg: []char)
		do @listInfo.add(msg)
		do @fillErrColor(pos.col, pos.row - 1)
	end func
end func

func showHint()
	var charColor: @CharColor
	var word: []char :: getWord(&charColor)
	if(word <>& null)
		var hint: []char
		switch(charColor)
		case %none
		case %identifier
			do hint :: ##@getHint(word, "\\" ~ file@delExt(file@fileName(@mainSrcName)), @cursorY)
		case %global
		case %reserved
			switch(word)
			case "if"
				do hint :: "if BlockName(cond)\n\t...\nend if"
			end switch
		end switch
		if(hint <>& null)
			do @editLog.setText(hint)
		end if
	end if

	func getWord(color: &@CharColor): []char
		var x: int :: @cursorX
		var y: int :: @cursorY
		var color2: bit8
		if(@moveWordTop(&x, &y, &color2))
			var beginX: int :: x
			while(x < ^@curSrc.color[y] & @curSrc.color[y][x].and(16#7Fb8) = color2)
				do x :+ 1
			end while
			if(beginX = x)
				ret null
			end if
			do color :: color2.and(16#7Fb8) $ @CharColor
			ret @curSrc.src[y].sub(beginX, x - beginX)
		end if
		ret null
	end func
end func

func moveWordTop(x: &int, y: &int, color: &bit8): bool
	if(y < 0)
		do y :: 0
	elif(^@curSrc.color <= y)
		do y :: ^@curSrc.color - 1
	end if
	if(1 <= x & x < ^@curSrc.color[y] & (@curSrc.src[y][x] = ' ' | @curSrc.src[y][x] = '\t' | @curSrc.color[y][x].and(16#7Fb8) = %comment $ @CharColor $ bit8 | @curSrc.color[y][x].and(16#7Fb8) = %symbol $ @CharColor $ bit8))
		do x :- 1
	end if
	if(x < 0)
		do x :: 0
	elif(^@curSrc.color[y] <= x)
		do x :: ^@curSrc.color[y] - 1
	end if
	if(^@curSrc.color[y] <> 0)
		do color :: @curSrc.color[y][x].and(16#7Fb8)
		while(x >= 1 & @curSrc.color[y][x - 1].and(16#7Fb8) = color)
			do x :- 1
		end while
		ret true
	end if
	ret false
end func

func fillErrColor(x: int, y: int)
	var color: bit8
	if(@moveWordTop(&x, &y, &color))
		while(x < ^@curSrc.color[y] & @curSrc.color[y][x].and(16#7Fb8) = color)
			do @curSrc.color[y][x] :: @curSrc.color[y][x].or(16#80b8)
			do x :+ 1
		end while
	end if
end func

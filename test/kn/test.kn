func [compiler.dll, BuildMem] build(path: []char, funcGetSrc: func<([]char): list<@Line>>, sysDir: []char, output: []char, icon: []char, rls_: bool, env: []char, funcLog: func<([][]char, int, int)>)
end func

func [compiler.dll, InitMemAllocator] initMemAllocator()
end func

func [compiler.dll, FinMemAllocator] finMemAllocator()
end func

func [compiler.dll, ResetMemAllocator] resetMemAllocator()
end func

func [compiler.dll, EditorInit] editorInit(me2: wnd@WndBase, funcIns: func<([]int, []char)>, funcCmd: func<([]int, int, int)>, funcReplace: func<([]int, int, []char)>)
end func

func [compiler.dll, EditorFin] editorFin()
end func

func [compiler.dll, EditorSetSrc] editorSetSrc(src: list<@Line>)
end func

var wndMain: wnd@Wnd
var tabSrc: wnd@Tab
var plainSrc: wnd@Plain
var scrollXSrc: wnd@ScrollX
var scrollYSrc: wnd@ScrollY
var editLog: wnd@EditMulti
var btnCompile: wnd@Btn
var listFile: wnd@List

class Line()
	+var src: []char
	+var indent: int
	+var commentLevel: int
	+var lineContinue: bool
end class

var srcs: dict<[]char, list<@Line>>
var mainSrc: []char
var curSrc: list<@Line>
var bufSrc: list<@Line>

func main()
	do @initMemAllocator()

	do @makeWnd()

	do @srcs :: #dict<[]char, list<@Line>>
	do @curSrc :: #list<@Line>
	do @srcs.add("_default_.kn", @curSrc)

	do @mainSrc :: "_default_.kn"
	var line: @Line :: #@Line
	do line.src :: "piyo"
	do line.indent :: 0
	do line.commentLevel :: 0
	do line.lineContinue :: false
	do @curSrc.add(line)
	var line2: @Line :: #@Line
	do line2.src :: "aaa"
	do line2.indent :: 0
	do line2.commentLevel :: 0
	do line2.lineContinue :: false
	do @curSrc.add(line2)

	do @editorInit(@plainSrc, @onIns, @onCmd, @onReplace)
	do @editorSetSrc(@curSrc)

	while(wnd@act())
	end while

	do @editorFin()

	do @finMemAllocator()
end func

func makeWnd()
	var scrollWidth: int :: 17

	do @wndMain :: wnd@makeWnd(null, %normal, 1024, 768, "Kuin Programming Language")
	do @tabSrc :: wnd@makeTab(@wndMain, 0, 0, 1024 - 200, 768 - 100, %scale, %scale)
	do @plainSrc :: wnd@makePlain(@tabSrc, 0, 50, 1024 - 200 - scrollWidth, 768 - 150 - scrollWidth, %scale, %scale)
	do @scrollXSrc :: wnd@makeScrollX(@tabSrc, 0, 50 + 768 - 150 - scrollWidth, 1024 - 200 - scrollWidth, scrollWidth, %scale, %move)
	do @scrollYSrc :: wnd@makeScrollY(@tabSrc, 0 + 1024 - 200 - scrollWidth, 50, scrollWidth, 768 - 150 - scrollWidth, %move, %scale)
	do @editLog :: wnd@makeEditMulti(@wndMain, 0, 768 - 100, 1024, 100, %scale, %move)
	do @btnCompile :: wnd@makeBtn(@wndMain, 1024 - 200, 0, 200, 50, %move, %fix, "Compile")
	do @btnCompile.onPush :: @btnCompileOnPush
	do @listFile :: wnd@makeList(@wndMain, 1024 - 200, 384, 200, 384 - 100, %move, %scale)
end func

func btnCompileOnPush()
	do @resetMemAllocator()
	do @editLog.setText("")
	do @build(@mainSrc, @getSrc, null, null, null, false, "cui", @log)
end func

func getSrc(path: []char): list<@Line>
	var result: list<@Line> :: @srcs.get(path)
	do @bufSrc :: result
	if(result <>& null)
		ret result
	end if
	ret @loadSrc(path)
end func

func loadSrc(path: []char): list<@Line>
	var filePtr: file@Reader :: file@makeReader(path)
	if(filePtr =& null)
		ret null
	end if
	do filePtr.delimiter("")
	var result: list<@Line> :: #list<@Line>
	while(!filePtr.term())
		var line: @Line :: #@Line
		do line.src :: filePtr.readLine()
		do line.indent :: 0
		do line.commentLevel :: 0
		do line.lineContinue :: false
		do result.add(line)
	end while
	do filePtr.fin()
	do @srcs.add(##path, result)
	do @bufSrc :: result
	ret result
end func

func toStr(s: []char): []char
	ret s =& null ?("(null)", s)
end func

func log(args: [][]char, row: int, col: int)
	do @editLog.setText(@editLog.getText() ~ @toStr(args[0]) ~ ", " ~ @toStr(args[1]) ~ ", " ~ @toStr(args[2]) ~ ", " ~ row.toStr() ~ ", " ~ col.toStr() ~ "\n")
end func

func onIns(pos: []int, str: []char)
	do @curSrc.headOffset(pos[1])
	var line: @Line :: @curSrc.get()
	do line.src :: line.src.sub(0, pos[0]) ~ str ~ line.src.sub(pos[0], -1)
end func

func onCmd(pos: []int, len: int, cmd: int)
	do @curSrc.headOffset(pos[1])
	var line: @Line :: @curSrc.get()
	switch(cmd)
	case 0 {back space}
		if(pos[0] = 0)
			if(!@curSrc.termOffset(-1))
				var line2: @Line :: @curSrc.getOffset(-1)
				do line2.src :: line2.src ~ line.src
				do @curSrc.del()
			end if
		else
			do line.src :: line.src.sub(0, pos[0] - 1) ~ line.src.sub(pos[0], -1)
		end if
	case 1 {delete}
		for(1, len)
			if(pos[0] = ^line.src)
				if(!@curSrc.termOffset(1))
					var line2: @Line :: @curSrc.getOffset(1)
					do line.src :: line.src ~ line2.src
					do @curSrc.delNext()
				end if
			else
				do line.src :: line.src.sub(0, pos[0]) ~ line.src.sub(pos[0] + 1, -1)
			end if
		end for
	case 2 {return}
		var line2: @Line :: #@Line
		do line2.src :: line.src.sub(pos[0], -1)
		do line2.indent :: 0
		do line2.commentLevel :: 0
		do line2.lineContinue :: false
		do line.src :: line.src.sub(0, pos[0])
		if(@curSrc.termOffset(1))
			do @curSrc.add(line2)
		else
			do @curSrc.next()
			do @curSrc.ins(line2)
		end if
	end switch
end func

func onReplace(pos: []int, len: int, str: []char)
end func
